<p style="color:gray; margin:0 0 0.5em;">1</p>

# Введение
Почти все компьютерные системы в целом, и встраиваемые системы в частности, являются **событийно-управляемыми**, что означает, что они постоянно ожидают наступления некоторого внешнего или внутреннего события, такого как тик таймера, приход пакета данных, нажатие кнопки или клик мыши. После распознавания события такие системы реагируют, выполняя соответствующие вычисления, которые могут включать манипулирование аппаратным обеспечением или генерацию "программных" событий, которые запускают другие внутренние программные компоненты. (Вот почему событийно-управляемые системы также называют **реактивными системами**.) Как только обработка события завершена, программное обеспечение возвращается к ожиданию следующего события.

Вы, несомненно, привыкли к базовому последовательному управлению, при котором программа ожидает события в различных точках своего пути выполнения, либо активно опрашивая события (**polling**), либо пассивно блокируясь на семафоре или другом подобном механизме операционной системы. Хотя этот подход к программированию событийно-управляемых систем функционален во многих ситуациях, он не очень хорошо работает, когда существует несколько возможных источников событий, время и порядок прибытия которых вы не можете предсказать, и где важно обрабатывать события своевременно. Проблема в том, что пока последовательная программа ожидает один тип события, она не выполняет никакой другой работы и не реагирует на другие события.

Очевидно, что нам нужна структура программы, которая может реагировать на множество возможных событий, любое из которых может прийти в непредсказуемое время и в непредсказуемой последовательности. Хотя эта проблема очень распространена во встраиваемых системах, таких как бытовая техника, сотовые телефоны, промышленные контроллеры, медицинские устройства и многие другие, она также очень распространена в современных настольных компьютерах. Подумайте об использовании веб-браузера, текстового процессора или электронной таблицы. Большинство этих программ имеют современный графический пользовательский интерфейс (GUI), который, очевидно, способен обрабатывать несколько событий. Все разработчики

***

<p style="color:gray; margin:0 0 0.5em;">2 (xxviii) Введение</p>

современных систем с GUI и многих встраиваемых приложений приняли общую структуру программы, которая элегантно решает проблему обработки множества асинхронных событий своевременным образом. Эта структура программы обычно называется **событийно-управляемым программированием**.

## Инверсия управления
Событийно-управляемое программирование требует совершенно иного способа мышления, чем традиционные последовательные программы, такие как "суперциклы" (superloops) или задачи в традиционной ОСРВ (RTOS). Большинство современных событийно-управляемых систем структурированы в соответствии с **принципом Голливуда**, что означает "Не звоните нам, мы сами вам позвоним". Таким образом, событийно-управляемая программа *не контролирует* ситуацию в ожидании события; на самом деле, она даже не активна. Только когда событие приходит, программа вызывается для его обработки, а затем быстро возвращает управление обратно. Такое устройство позволяет событийно-управляемой системе ожидать множество событий параллельно, поэтому система остается отзывчивой ко всем событиям, которые ей необходимо обработать.

Эта схема имеет три важных следствия. Во-первых, это означает, что событийно-управляемая система естественным образом делится на **приложение**, которое фактически обрабатывает события, и **управляющую событийно-управляемую инфраструктуру**, которая ожидает события и направляет их приложению. Во-вторых, управление находится в событийно-управляемой инфраструктуре, поэтому с точки зрения приложения управление *инвертировано* по сравнению с традиционной последовательной программой. И в-третьих, событийно-управляемое приложение должно возвращать управление после обработки каждого события, поэтому контекст выполнения не может быть сохранен в стековых переменных и счетчике команд, как в последовательной программе. Вместо этого событийно-управляемое приложение становится **стейт-машиной** (state machine), или, на самом деле, набором взаимодействующих стейт-машин, которые сохраняют контекст от одного события к другому в статических переменных.

## Важность событийно-управляемого фреймворка
**Инверсия управления**, столь типичная для всех событийно-управляемых систем, придает событийно-управляемой инфраструктуре все определяющие характеристики **фреймворка** приложения, а не набора инструментов (toolkit). Когда вы используете набор инструментов, такой как традиционная операционная система или ОСРВ, вы пишете основную часть приложения и вызываете код из набора инструментов, который хотите использовать повторно. Когда вы используете фреймворк, вы повторно используете основную часть и пишете код, который *она вызывает*.

Другой важный момент заключается в том, что событийно-управляемый фреймворк на самом деле необходим, если вы хотите объединить несколько событийно-управляемых стейт-машин в системы. Для выполнения параллельных стейт-машин действительно требуется нечто большее, чем "просто" API, такое как традиционная ОСРВ.

***

<p style="color:gray; margin:0 0 0.5em;">3 (xxix) Введение</p>

Стейт-машинам требуется инфраструктура (фреймворк), которая обеспечивает, как минимум, контекст выполнения **run-to-completion (RTC)** для каждой стейт-машины, организацию очередей событий и сервисы таймеров на основе событий. Это действительно ключевой момент. Стейт-машины не могут работать в вакууме и не очень практичны без событийно-управляемого фреймворка.

## Вычислительная модель активного объекта
Эта книга объединяет две наиболее эффективные техники декомпозиции событийно-управляемых систем: иерархические стейт-машины и событийно-управляемый фреймворк. Комбинация этих двух элементов известна как **вычислительная модель активного объекта** (active object computing model). Термин **активный объект** (active object) происходит из UML и обозначает автономный объект, асинхронно взаимодействующий с другими активными объектами посредством событий. Далее UML предлагает использовать UML-вариант стейтчартов (statecharts) для моделирования поведения событийно-управляемых активных объектов.

В этой книге активные объекты реализуются с помощью событийно-управляемого фреймворка под названием QF, который является основным компонентом событийно-управляемой платформы QP. Фреймворк QF упорядоченно выполняет активные объекты и обрабатывает все детали потокобезопасного обмена и обработки событий внутри активных объектов. QF гарантирует общепринятую семантику RTC для выполнения стейт-машин, ставя события в очередь и отправляя их последовательно (по одному) внутренним стейт-машинам активных объектов.

Фундаментальные концепции иерархических стейт-машин в сочетании с событийно-управляемым фреймворком не новы. Фактически, они широко используются уже как минимум два десятилетия. Практически все коммерчески успешные инструменты автоматизации проектирования на сегодняшнем рынке основаны на иерархических стейт-машинах (стейтчартах) и внутренне включают вариант событийно-управляемого фреймворка реального времени, подобного QF.

## Кодо-центричный подход
Подход, который я принимаю в этой книге, является **кодо-центричным**, минималистичным и низкоуровневым. Эта характеристика не является уничижительной; она просто означает, что вы научитесь отображать иерархические стейт-машины и активные объекты непосредственно в исходный код на C или C++, без больших инструментов. Вопрос здесь не в инструменте — вопрос в понимании.

Современные инструменты автоматизации проектирования действительно мощны, но они не для всех. Для многих разработчиков инструмент просто не оправдывает своей сложности и от него отказываются. Для таких разработчиков кодо-центричный подход, представленный в этой книге, может стать легковесной альтернативой тяжеловесным инструментам.

***

<p style="color:gray; margin:0 0 0.5em;">4 (xxx) Введение</p>

Однако самое важное то, что никакой инструмент не может заменить концептуальное понимание. Например, определение того, какие действия выхода (exit) и входа (entry) и в какой последовательности выполняются при нетривиальном переходе состояний, — это не то, что вы должны выяснять, запуская анимацию вашей стейт-машины с помощью инструмента. Ответ должен исходить из вашего понимания лежащей в основе реализации стейт-машины (обсуждается в Главах 3 и 4). Даже если вы позже решите использовать инструмент автоматизации проектирования, и даже если этот конкретный инструмент будет использовать другую технику реализации стейтчартов, чем та, что обсуждается в этой книге, вы все равно будете применять концепции с большей уверенностью и эффективностью благодаря вашему пониманию фундаментальных механизмов на низком уровне.

Несмотря на многочисленные давления со стороны существующих пользователей, я настоял на том, чтобы платформа QP оставалась компактной, реализуя напрямую только основные элементы громоздкой спецификации UML и поддерживая тонкости в виде паттернов проектирования. Сохранение компактности и простоты основной реализации имеет реальные преимущества. Программисты могут быстро изучить и развернуть QP без больших вложений в инструменты и обучение. Они могут легко адаптировать и настраивать исходный код фреймворка для конкретной ситуации, в том числе для встраиваемых систем с сильно ограниченными ресурсами. Они могут понять и, действительно, регулярно использовать все предоставленные функции.

## Фокус на реальных задачах
Нельзя просто рассматривать стейт-машины и событийно-управляемый фреймворк как набор функций, потому что некоторые из этих функций не будут иметь смысла в изоляции. Вы можете эффективно использовать эти мощные концепции, только если вы думаете о проектировании, а не просто о кодировании. А чтобы понимать стейт-машины таким образом, вы должны понимать проблемы событийно-управляемого программирования в целом.

Эта книга обсуждает проблемы событийно-управляемого программирования, почему они являются проблемами, и как стейт-машины и модель вычислений с активными объектами могут помочь. Таким образом, я начинаю большинство глав с проблем программирования, которые будут рассмотрены в главе. Таким образом, я надеюсь постепенно подвести вас к точке, где иерархические стейт-машины и событийно-управляемый фреймворк станут гораздо более естественным способом решения проблем, чем традиционные подходы, такие как глубоко вложенные `IF` и `ELSE` для кодирования поведений с состоянием или передача событий через семафоры или флаги событий традиционной ОСРВ.

***

<p style="color:gray; margin:0 0 0.5em;">5 (xxxi) Введение</p>
## Объектная ориентация
Хотя я использую C в качестве основного языка программирования, я также широко применяю принципы объектно-ориентированного проектирования. Как и практически все фреймворки приложений, QP использует базовые концепции инкапсуляции (классы) и одиночного наследования в качестве основных механизмов настройки, специализации и расширения фреймворка для конкретного приложения. Не волнуйтесь, если эти концепции для вас новы, особенно в C. На уровне языка C инкапсуляция и наследование становятся просто идиомами кодирования, которые я представляю в Главе 1. Я специально избегаю полиморфизма в C-версии, потому что реализация позднего связывания в C немного сложнее. Конечно, C++ версия использует классы и наследование напрямую, и приложения QP/C++ могут использовать полиморфизм.

## Больше удовольствия
Когда вы начнете использовать техники, описанные в этой книге, ваши проблемы изменятся. Вы больше не будете бороться с 15 уровнями запутанных операторов `if-else`, и вы перестанете беспокоиться о семафорах или других подобных низкоуровневых механизмах ОСРВ. Вместо этого вы начнете думать на более высоком уровне абстракции о стейт-машинах, событиях и активных объектах. После того как вы испытаете этот квантовый скачок, вы обнаружите, как и я, что программирование может быть гораздо более увлекательным. Вы никогда не захотите возвращаться к "спагетти-коду" или сырой ОСРВ.

## Как со мной связаться
Если у вас есть комментарии или вопросы по этой книге, коду или событийно-управляемому программированию в целом, я буду рад вас услышать. Пожалуйста, напишите мне по адресу
miro@state-machine.com.

***

<p style="color:gray; margin:0 0 0.5em;">6</p>

(Карикатура: два пещерных человека, один показывает другому каменное колесо)

"МОЖЕТ, ЭТО И НЕ ИДЕАЛЬНОЕ КОЛЕСО, НО ЭТО КОЛЕСО ПОСЛЕДНЕГО СЛОВА ТЕХНИКИ."
www.CartoonStock.com

# ЧАСТЬ I UML СТЕЙТ-МАШИНЫ
Стейт-машины (конечные автоматы) — это наиболее известный формализм для спецификации и реализации событийно-управляемых систем, которые должны своевременно реагировать на входящие события. Продвинутые UML стейт-машины представляют собой современное состояние теории и нотации стейт-машин.

Часть I этой книги показывает практические способы использования UML стейт-машин в событийно-управляемых приложениях, чтобы помочь вам создавать эффективное и поддерживаемое программное обеспечение с хорошо понятным поведением, вместо создания "спагетти-кода", усеянного запутанными `IF` и `ELSE`. Глава 1 представляет обзор метода на рабочем примере.

***

<p style="color:gray; margin:0 0 0.5em;">7 (2) Часть I</p>

Глава 2 знакомит с концепциями стейт-машин и нотацией UML. Глава 3 показывает стандартные техники кодирования стейт-машин, а Глава 4 описывает общий иерархический обработчик событий. Часть I завершается Главой 5, которая представляет мини-каталог из пяти паттернов проектирования состояний. Вы узнаете, что UML стейт-машины — это мощный метод проектирования, который вы можете использовать даже без сложных инструментов для синтеза кода.

***

<p style="color:gray; margin:0 0 0.5em;">8 ГЛАВА 1</p>
## Начинаем работу с UML стейт-машинами и событийно-управляемым программированием

*Здравый смысл подсказывает взять метод и попробовать его. Если он не сработает, честно признайте это и попробуйте другой. Но прежде всего, попробуйте что-нибудь.*
—Франклин Д. Рузвельт

Эта глава представляет пример проекта, полностью реализованного с использованием UML стейт-машин и событийно-управляемой парадигмы. Пример приложения — это интерактивная игра типа "Летай и стреляй" ("Fly 'n' Shoot"), которую я решил включить в начало книги, чтобы вы могли как можно скорее начать играть (в буквальном смысле) с кодом. Моя цель в этой главе — показать основные элементы метода на реальной, нетривиальной программе, но без углубления в детали, правила и исключения. На данном этапе я не стремлюсь быть полным или даже точным, хотя этот пример, как и все другие примеры в книге, предназначен для демонстрации хорошего дизайна и рекомендуемого стиля кодирования. Я не предполагаю, что вы много знаете о UML стейт-машинах, UML нотации или событийно-управляемом программировании. Я буду кратко вводить концепции по мере необходимости или отсылать вас к последующим главам книги для получения более подробной информации.

Пример игры "Fly 'n' Shoot" основан на приложении Quickstart, предоставленном в исходном коде с оценочным комплектом Stellaris EV-LM3S811 от Luminary Micro [Luminary 06]. Я пытался сделать так, чтобы пример "Fly 'n' Shoot" вел себя очень похоже на оригинальное приложение Luminary Micro Quickstart, чтобы вы могли напрямую сравнить событийно-управляемый подход с традиционным решением по существу той же спецификации задачи.

***

<p style="color:gray; margin:0 0 0.5em;">9 (4) Глава 1</p>
## 1.1 Установка сопутствующего кода
Сопутствующий веб-сайт к этой книге по адресу www.state-machine.com/psicc2 содержит самораспаковывающийся архив с полным исходным кодом событийно-управляемой платформы QP и всеми исполняемыми примерами, описанными в этой книге; а также документацию, инструменты разработки, ресурсы и многое другое. Вы можете распаковать архив в любой каталог. Выбранный вами каталог установки в дальнейшем будет называться корневым каталогом QP `<qp>`.

> **ПРИМЕЧАНИЕ**
> Хотя в тексте я в основном концентрируюсь на реализации на C, сопутствующий веб-сайт также содержит эквивалентную C++ версию практически каждого элемента, доступного на C. Код на C++ организован в точно такой же древовидной структуре каталогов, что и соответствующий код на C, за исключением того, что вам нужно смотреть в ветку каталога `<qp>\qpcpp\...`.

Что касается примера "Fly 'n' Shoot", сопутствующий код содержит две версии¹ игры. Я предоставляю DOS-версию для стандартного ПК на базе Windows (см. Рисунок 1.1), чтобы вам не требовалась специальная встраиваемая плата для игры и экспериментов с кодом.

> **ПРИМЕЧАНИЕ**
> Я выбрал устаревшую 16-битную DOS-платформу, потому что она позволяет программировать стандартный ПК на "голом железе". Не покидая своего рабочего стола, вы можете работать с прерываниями, напрямую манипулировать регистрами ЦП и напрямую обращаться к пространству ввода-вывода. Никакая другая современная 32-битная среда разработки для стандартного ПК не позволяет этого так легко. Вездесущий ПК под управлением DOS (или консоли DOS в любой версии Windows) настолько близок к эмуляции разработки встраиваемого ПО на обычном оборудовании 80x86, насколько это возможно. Кроме того, вы можете использовать бесплатные, зрелые инструменты, такие как компилятор Borland C/C++.

Я также предоставляю встраиваемую версию для недорогого² оценочного комплекта Stellaris EV-LM3S811 на базе ARM Cortex-M3 (см. Рисунок 1.2). Обе версии, для ПК и Cortex-M3,

---
¹ Сопутствующий код на самом деле содержит гораздо больше версий игры "Fly 'n' Shoot", но на данном этапе они не имеют значения.
² На момент написания этой статьи комплект EV-LM3S811 был доступен за $49 (www.luminarymicro.com).

***


## 1.1 Установка сопутствующего кода
Сопутствующий веб-сайт к этой книге по адресу www.state-machine.com/psicc2 содержит самораспаковывающийся архив с полным исходным кодом событийно-управляемой платформы QP и всеми исполняемыми примерами, описанными в этой книге; а также документацию, инструменты разработки, ресурсы и многое другое. Вы можете распаковать архив в любой каталог. Выбранный вами каталог установки в дальнейшем будет называться корневым каталогом QP `<qp>`.
## 1.2 Давайте поиграем
Следующее описание игры "Fly 'n' Shoot" служит двойной цели: объяснить, как играть в игру, и служить спецификацией задачи для проектирования и реализации программного обеспечения далее в этой главе. Для достижения этих двух целей мне нужно быть довольно подробным, так что, пожалуйста, потерпите.

Ваша цель в игре — провести космический корабль через бесконечный горизонтальный туннель с минами. Любое столкновение с туннелем или миной уничтожает корабль. Вы можете перемещать корабль вверх и вниз с помощью клавиш со стрелками вверх и вниз на ПК (см. Рисунок 1.1) или с помощью колеса потенциометра на плате EV-LM3S811 (см. Рисунок 1.2). Вы также можете выпустить ракету для уничтожения мин, нажав пробел на ПК или кнопку User на плате EV-LM3S811. Очки начисляются за выживание (со скоростью 30 очков в секунду) и за уничтожение мин. Игра длится только на один корабль.

Игра начинается в демо-режиме, где стенки туннеля прокручиваются с нормальной скоростью справа налево, а в середине экрана мигает текст "Press Button". Вам нужно сгенерировать событие "fire missile" (выстрел ракетой), чтобы начать игру (нажать пробел на ПК или кнопку User на плате EV-LM3S811).

Одновременно в полете может быть только одна ракета, поэтому попытка выстрелить ракетой, пока она уже летит, не имеет никакого эффекта. Попадание ракетой в стену туннеля не приносит очков, но вы зарабатываете дополнительные очки за уничтожение мин.

В игре есть два типа мин с разным поведением. В оригинальном приложении Luminary Quickstart оба типа мин ведут себя одинаково, но я хотел продемонстрировать, как стейт-машины могут элегантно обрабатывать по-разному ведущие себя мины.

Мина типа 1 маленькая, но ее можно уничтожить, попав в любой из ее пикселей ракетой. Вы зарабатываете 25 очков за уничтожение мины типа 1. Мина типа 2 больше, но более коварна в том, что ракета может уничтожить ее, только попав в ее центр, а не в какое-либо из "щупалец". Конечно, корабль уязвим для всей мины. Вы зарабатываете 45 очков за уничтожение мины типа 2.

Когда вы разбиваете корабль, столкнувшись со стеной или миной, игра заканчивается и на экране появляется мигающий текст "Game Over", а также ваш итоговый счет. После 5 секунд мигания,

***

6
Глава 1
экран "Game Over" сменяется обратно на демо-экран, где игра ожидает нового запуска.

Кроме того, приложение содержит хранитель экрана, поскольку OLED-дисплей оригинальной платы EV-LM3S811 имеет характеристики выгорания, схожие с ЭЛТ. Хранитель экрана активируется только в том случае, если в демо-режиме проходит 20 секунд без запуска игры (т.е. хранитель экрана никогда не появляется во время игрового процесса). Хранитель экрана представляет собой простой тип случайных пикселей, а не алгоритм "Game of Life", использованный в оригинальном приложении Luminary Quickstart. Я решил упростить этот аспект реализации, поскольку более сложный алгоритм смешивания пикселей не добавляет никакого нового или интересного поведения.

Через минуту работы хранителя экрана дисплей гаснет, и на экране отображается только один случайный пиксель. Опять же, это немного отличается от оригинального приложения Quickstart, которое вместо этого гасит экран и начинает мигать пользовательским светодиодом. Я изменил это поведение, потому что у меня есть лучшая цель для пользовательского светодиода (визуализация активности цикла ожидания).

**(Изображение: Скриншот игры 'Fly 'n' Shoot' в окне командной строки DOS)**

**Рисунок 1.1:** Игра "Fly 'n' Shoot", запущенная в окне DOS под Windows XP.

(Подписи на скриншоте)
FLY 'n' SHOOT
Нажмите UP-arrow, чтобы поднять корабль вверх
Нажмите DOWN-arrow, чтобы опустить корабль вниз
Нажмите SPACE, чтобы выстрелить ракетой
Нажмите ESC, чтобы выйти из игры

Ship Position: 9 | Triggers: 4 | Score: 719

[Корабль] [Ракета] [Мина Тип 1] [Взрыв] [Мина Тип 2] [Стена туннеля]

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 7

**(Изображение: Оценочная плата Stellaris EV-LM3S811 с подписями к компонентам)**

**Рисунок 1.2:** Игра "Fly 'n' Shoot", запущенная на оценочной плате Stellaris EV-LM3S811.

(Подписи к компонентам на изображении)
- Колесо потенциометра
- Кнопка сброса
- LM3S811 Cortex-M3 MCU
- 96 x 16 OLED-дисплей
- Светодиод питания
- USB-кабель к ПК
- LMI FTDI отладчик
- Пользовательский светодиод
- Пользовательский переключатель

### 1.2.1 Запуск DOS-версии
Пример кода "Fly 'n' Shoot" для DOS-версии (на C) находится в каталоге `<qp>\qpc\examples\80x86\dos\tcpp101\1\game\`, где `<qp>` обозначает каталог установки, в который вы решили установить сопутствующее программное обеспечение.

Скомпилированный исполняемый файл предоставлен, так что вы можете запустить игру на любом ПК с Windows, просто дважды щелкнув исполняемый файл `game.exe`, находящийся в каталоге `<qp>\qpc\examples\80x86\dos\tcpp101\1\game\dbg\`. Первый экран, который вы увидите, — это игра, работающая в демо-режиме с мигающим текстом "Push Button" в середине дисплея. В верхней части дисплея вы увидите легенду клавиш, распознаваемых приложением. Вам нужно нажать `ПРОБЕЛ`, чтобы начать игру. Нажмите клавишу `Esc`, чтобы корректно выйти из приложения.

Если вы запускаете "Fly 'n' Shoot" в окне под Microsoft Windows, анимационные эффекты в игре могут показаться немного прерывистыми, особенно по сравнению с версией для Stellaris той же игры. Вы можете сделать выполнение приложения значительно более плавным, если переключитесь в полноэкранный режим, нажав и удерживая клавишу `Alt`, а затем нажав клавишу `Enter`. Вы вернетесь в оконный режим с помощью той же комбинации клавиш `Alt-Enter`.

Как вы можете видеть на Рисунке 1.1, DOS-версия использует просто стандартный текстовый режим VGA для эмуляции OLED-дисплея платы EV-LM3S811. Нижняя часть экрана DOS

***

8
Глава 1
используется как матрица "пикселей" шириной 80 × 16 символов, что немного меньше, чем 96 × 16 пикселей OLED-дисплея, но все же достаточно хорошо для игры. Я специально избегаю использования какой-либо более сложной графики в этом раннем примере, потому что у меня есть более важные дела для вас, чем беспокоиться о несущественных сложностях программирования графики.

Моя главная цель — сделать так, чтобы вам было легко понять событийно-управляемый код и экспериментировать с ним. С этой целью я выбрал устаревший набор инструментов Borland Turbo C++ 1.01 для сборки этого примера, а также нескольких других примеров в этой книге. Несмотря на то, что Turbo C++ 1.01 — старый компилятор, он адекватен для демонстрации всех возможностей как C, так и C++ версий. Лучше всего то, что он доступен для бесплатной загрузки из "Музея" Borland по адресу http://bdn.borland.com/article/0,1410,21751,00.html.

Набор инструментов очень легко установить. После того как вы загрузите файлы Turbo C++ 1.01 непосредственно с сайта Borland, вам нужно распаковать их на ваш жесткий диск. Затем вы запускаете программу `INSTALL.EXE` и следуете инструкциям по установке, которые она предоставляет.

> **ПРИМЕЧАНИЕ**
> Я настоятельно рекомендую установить набор инструментов Turbo C++ 1.01 в каталог `C:\tools\tcpp101\`. Таким образом, вы сможете напрямую использовать предоставленные файлы проектов и make-скрипты.

Возможно, самый простой способ экспериментировать с кодом "Fly 'n' Shoot" — это запустить Turbo C++ IDE (`TC.EXE`) и открыть предоставленный файл проекта `GAME-DBG.PRJ`, который находится в каталоге `<qp>\qpc\examples\80x86\dos\tcpp101\1\game\`. Вы можете изменять, перекомпилировать, выполнять и отлаживать программу прямо из IDE. Однако вам следует избегать завершения программы, остановленной в отладчике, потому что это не восстановит стандартные векторы прерываний DOS для таймера и клавиатуры. Вы всегда должны корректно выходить из приложения, позволяя ему свободно работать и нажимая клавишу `Esc`.

Следующий раздел кратко описывает, как запустить встраиваемую версию игры. Если вас не интересует версия для Cortex-M3, не стесняйтесь перейти к Разделу 1.3, где я начинаю объяснять код приложения.

### 1.2.2 Запуск версии для Stellaris
В отличие от версии "Fly 'n' Shoot" для DOS, работающей в древнем реальном режиме процессора 80x86, точно такой же исходный код работает на одном из самых современных процессоров в индустрии: ARM Cortex-M3.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием
9
Пример кода для платы Stellaris EV-LM3S811 находится в каталоге `<qp>\qpc\examples\cortex-m3\vanilla\iar\game-ev-lm3s811\`, где `<qp>` обозначает корневой каталог, в который вы решили установить сопутствующее программное обеспечение.

Код для комплекта Stellaris был скомпилирован с помощью 32-килобайтной ограниченной версии Kickstart IAR Embedded Workbench for ARM (IAR EWARM) v 5.11, которая поставляется с комплектом Stellaris EV-LM3S811. Вы также можете бесплатно загрузить это программное обеспечение непосредственно с сайта IAR Systems (www.iar.com) после заполнения онлайн-регистрации.

Установка IAR EWARM довольно проста, так как программное обеспечение поставляется с утилитой установки. Вам также необходимо установить USB-драйверы для аппаратного отладчика, встроенного в плату EV-LM3S811, как описано в документации к комплекту Stellaris EV-LM3S811.

> **ПРИМЕЧАНИЕ**
> Я настоятельно рекомендую установить набор инструментов IAR EWARM в каталог `C:\tools\iar\arm_ks_5.11`. Таким образом, вы сможете напрямую использовать предоставленные файлы рабочего пространства EWARM и make-скрипты.

Прежде чем программировать игру "Fly 'n' Shoot" на плату EV-LM3S811, вы можете немного поиграть с оригинальным приложением Quickstart, которое поставляется предварительно запрограммированным с комплектом EV-LM3S811.

Чтобы запрограммировать игру "Fly 'n' Shoot" во флэш-память платы EV-LM3S811, сначала подключите плату EV-LM3S811 к вашему ПК с помощью USB-кабеля, предоставленного в комплекте, и убедитесь, что светодиод питания горит (см. Рисунок 1.2). Затем вам нужно запустить IAR Embedded Workbench и открыть рабочее пространство `game-ev-lm3s811.eww`, расположенное в каталоге `<qp>\qpc\examples\cortex-m3\vanilla\iar\game-ev-lm3s811\`. На этом этапе ваш экран должен выглядеть так же, как на скриншоте, показанном на Рисунке 1.3.

Проект `game-ev-lm3s811` настроен на использование отладчика LMI FTDI, который является частью оборудования, интегрированного на плату EV-LM3S811 (см. Рисунок 1.2). Вы можете проверить эту настройку, открыв диалоговое окно "Options" через меню `Project | Options`. В диалоговом окне "Options" вам нужно выбрать категорию `Debugger` на панели слева. Пока вы там, вы также можете проверить, что загрузка во флэш-память включена, выбрав вкладку "Download". Установленный флажок "Use flash loader(s)" означает

***

10
Глава 1
что приложение-загрузчик флэш-памяти, предоставленное IAR, сначала будет загружено в ОЗУ микроконтроллера, и это приложение запрограммирует флэш-память образом вашего приложения.

Чтобы начать процесс программирования флэш-памяти, выберите меню `Project | Debug` или просто нажмите кнопку `Debug` (см. Рисунок 1.3) на панели инструментов. IAR Workbench должен отреагировать, показав на несколько секунд индикатор выполнения программирования флэш-памяти, как показано на Рисунке 1.3. Как только программирование флэш-памяти завершится, IAR EWARM переключится на отладчик IAR C-Spy, и программа должна остановиться на входе в `main()`. Вы можете начать играть в игру, либо нажав кнопку `Go` в отладчике, либо закрыв отладчик и сбросив плату нажатием кнопки `Reset`. В любом случае, игра "Fly 'n' Shoot" теперь постоянно запрограммирована на плату EV-LM3S811 и будет запускаться автоматически при каждом включении питания.

**(Изображение: Скриншот IDE IAR Embedded Workbench, показывающий процесс загрузки игры)**

**Рисунок 1.3:** Загрузка игры "Fly 'n' Shoot" во флэш-память микроконтроллера LM3S811 с помощью IAR EWARM IDE.

(Подписи на изображении)
- **Workspace:** (показывает структуру файлов проекта)
- **Build Configuration Selection:** (выбор конфигурации сборки)
- **Debug Button:** (кнопка отладки)
- **QP Libraries:** (библиотеки QP)
- **Application Sources:** (исходные файлы приложения)
- **Flash Programming Progress:** (индикатор выполнения программирования)
- **Messages:** (окно сообщений)

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием
11
Среда IAR Embedded Workbench позволяет очень легко экспериментировать с кодом "Fly 'n' Shoot". Вы можете редактировать файлы и перекомпилировать приложение одним нажатием кнопки (F7). Единственное предостережение заключается в том, что в первый раз после установки набора инструментов IAR вам необходимо собрать библиотеку драйверов Luminary Micro для микроконтроллера LM3S811 из исходников. Вы делаете это, загружая рабочее пространство `ek-lm3s811.eww`, расположенное в каталоге `<IAR-EWARM>\ARM\examples\Luminary\Stellaris\boards\ek-lm3s811`, где `<IAR-EWARM>` обозначает имя каталога, в который вы установили набор инструментов IAR. В рабочем пространстве `ev-lm3s811.eww` вы выбираете проект "driverlib - Debug" из выпадающего списка в верхней части панели Workspace, а затем нажимаете F7 для сборки библиотеки.

## 1.3 Функция main()
Возможно, лучшее место для начала объяснения кода приложения "Fly 'n' Shoot" — это функция `main()`, расположенная в файле `main.c`. Если в этой главе не указано иное, вы можете просматривать код как в DOS-версии, так и в версии для EV-LM3S811, потому что исходный код приложения идентичен в обеих версиях. Полный файл `main.c` показан в Листинге 1.1.

> **ПРИМЕЧАНИЕ**
> Для объяснения листингов кода я ставлю номера в скобках у интересных строк в левом поле листинга. Затем я использую эти метки в левом поле раздела объяснений, который сразу следует за листингом. Иногда, чтобы однозначно сослаться на строку определенного листинга из разделов текста, отличных от раздела объяснений, я использую полную ссылку, состоящую из номера листинга, за которым следует метка. Например, Листинг 1.1(21) относится к метке (21) в Листинге 1.1.

**Листинг 1.1 Файл main.c приложения игры "Fly 'n' Shoot"**
```c
(1) #include "qp_port.h"      /* порт QP */
(2) #include "bsp.h"          /* Пакет поддержки платы */
(3) #include "game.h"         /* это приложение */

    /* Объекты с локальной областью видимости -------------------------------------*/
(4) static QEvent const * l_missileQueueSto[2];             /* очередь событий */
(5) static QEvent const * l_shipQueueSto[3];                /* очередь событий */
(6) static QEvent const * l_tunnelQueueSto[GAME_MINES_MAX + 5]; /* очередь событий */
```
*Продолжение на следующей странице*

***

12
Глава 1
```c
(7) static ObjectPosEvt   l_smlPoolSto[GAME_MINES_MAX + 8];  /* пул малого размера */
(8) static ObjectImageEvt l_medPoolSto[GAME_MINES_MAX + 8];  /* пул среднего размера */
(9) static QSubscrList    l_subscrSto[MAX_PUB_SIG];          /* публикация-подписка */

/*..........................................................................*/
void main(int argc, char *argv[]) {
    /* явно вызываем конструкторы активных объектов... */
(10) Missile_ctor();
(11) Ship_ctor();
(12) Tunnel_ctor();

(13) BSP_init(argc, argv); /* инициализируем Пакет поддержки платы */
(14) QF_init();            /* инициализируем фреймворк и ядро RT */
    
    /* инициализируем пулы событий... */
(15) QF_poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));
(16) QF_poolInit(l_medPoolSto, sizeof(l_medPoolSto), sizeof(l_medPoolSto[0]));

(17) QF_psInit(l_subscrSto, Q_DIM(l_subscrSto)); /* инициализируем публикацию-подписку */

    /* запускаем активные объекты... */
(18) QActive_start(AO_Missile, /* глобальный указатель на активный объект Missile */
                  1,          /* приоритет (самый низкий) */
                  l_missileQueueSto, Q_DIM(l_missileQueueSto), /* очередь событий */
                  (void*)0, 0,    /* нет стека для потока */
                  (QEvent *)0);   /* нет события инициализации */
(19) QActive_start(AO_Ship,    /* глобальный указатель на активный объект Ship */
                  2,          /* приоритет */
                  l_shipQueueSto, Q_DIM(l_shipQueueSto), /* очередь событий */
                  (void*)0, 0,    /* нет стека для потока */
                  (QEvent *)0);   /* нет события инициализации */
(20) QActive_start(AO_Tunnel,  /* глобальный указатель на активный объект Tunnel */
                  3,          /* приоритет */
                  l_tunnelQueueSto, Q_DIM(l_tunnelQueueSto), /* очередь событий */
                  (void*)0, 0,    /* нет стека для потока */
                  (QEvent *)0);   /* нет события инициализации */

(21) QF_run();             /* запускаем приложение QF */
}
```

(1) Игра "Fly 'n' Shoot" — это пример приложения, реализованного с помощью событийно-управляемой платформы QP. Каждый C-файл приложения, использующий QP, должен включать заголовочный файл `qp_port.h`. Этот заголовочный файл содержит специфическую адаптацию QP к данному процессору, операционной системе и компилятору, что называется **портом**. Каждый порт QP находится в отдельном каталоге, и компилятор C находит нужный заголовочный файл `qp_port.h` через путь поиска включаемых файлов, предоставленный компилятору.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 13
(обычно через опцию компилятора –I). Таким образом, мне не нужно изменять исходный код приложения, чтобы перекомпилировать его для другого процессора или компилятора. Мне нужно только указать компилятору искать в другом каталоге порта QP заголовочный файл `qp_port.h`. Например, DOS-версия включает заголовочный файл `qp_port.h` из каталога `<qp>\qpc\ports\80x86\dos\tcpp101\1\`, а версия для EV-LM3S811 — из каталога `<qp>\qpc\ports\cortex-m3\vanilla\iar\`.

(2) Заголовочный файл `bsp.h` содержит интерфейс к Пакету поддержки платы (Board Support Package) и находится в каталоге приложения.

(3) Заголовочный файл `game.h` содержит объявления событий и других средств, общих для компонентов приложения. Я обсужу этот заголовочный файл в предстоящем Разделе 1.7. Этот заголовочный файл находится в каталоге приложения.

Событийно-управляемая платформа QP представляет собой набор компонентов, таких как обработчик событий QEP, который выполняет стейт-машины в соответствии с семантикой UML, и фреймворк реального времени QF, который реализует вычислительную модель активных объектов. **Активные объекты** в QF — это инкапсулированные стейт-машины (каждая со своей очередью событий, отдельным контекстом задачи и уникальным приоритетом), которые асинхронно общаются друг с другом, отправляя и получая события, в то время как QF обрабатывает все детали потокобезопасного обмена и постановки событий в очередь. Внутри активного объекта события обрабатываются обработчиком QEP последовательно в режиме **run-to-completion (RTC)**, что означает, что обработка одного события должна обязательно завершиться до начала обработки следующего. (См. также Раздел 6.3.3 в Главе 6.)

(4-6) Приложение должно предоставить хранилище для очередей событий всех активных объектов, используемых в приложении. Здесь хранилище предоставляется во время компиляции через статически выделенные массивы неизменяемых (`const`) указателей на события, потому что очереди событий QF хранят только указатели на события, а не сами события. События представлены как экземпляры структуры `QEvent`, объявленной в заголовочном файле `qp_port.h`. Каждая очередь событий активного объекта может иметь разный размер, и вам нужно определить этот размер, исходя из ваших знаний о приложении. Очереди событий обсуждаются в Главах 6 и 7.

(7,8) Приложение также должно предоставить хранилище для **пулов событий**, которые фреймворк использует для быстрого и детерминированного динамического выделения событий. Каждый пул событий

***

14
Глава 1
может предоставлять блоки памяти только фиксированного размера. Чтобы избежать потерь памяти из-за использования блоков слишком большого размера для маленьких событий, фреймворк QF может управлять до трех пулов событий с блоками разного размера (для маленьких, средних и больших событий). Приложение "Fly 'n' Shoot" использует только два из трех возможных пулов событий (маленький и средний).

Фреймворк реального времени QF поддерживает два механизма доставки событий: простую прямую отправку событий активным объектам и более продвинутый механизм под названием **публикация-подписка**, который отделяет производителей событий от потребителей. В механизме публикации-подписки активные объекты подписываются на события через фреймворк. Производители событий публикуют события во фреймворке. При каждом запросе на публикацию фреймворк доставляет событие всем активным объектам, которые подписались на этот тип события. Одно очевидное следствие публикации-подписки заключается в том, что фреймворк должен хранить информацию о подписчиках, при этом должна быть возможность обрабатывать несколько подписчиков на любой данный тип события. Механизмы доставки событий описаны в Главах 6 и 7.

(9) Приложение "Fly 'n' Shoot" использует механизм доставки событий публикация-подписка, поддерживаемый QF, поэтому ему необходимо предоставить хранилище для списков подписчиков. Списки подписчиков запоминают, какие активные объекты подписались на какие события. Размер базы данных подписчиков зависит как от количества публикуемых событий, которое указывается в константе `MAX_PUB_SIG`, находящейся в заголовочном файле `game.h`, так и от максимального количества активных объектов, разрешенных в системе, которое определяется параметром конфигурации QF `QF_MAX_ACTIVE`.

(10-12) Эти функции выполняют раннюю инициализацию активных объектов в системе. Они играют роль статических "конструкторов", которые в C вам нужно вызывать явно. (C++ вызывает такие статические конструкторы неявно перед входом в `main()`).

(13) Функция `BSP_init()` инициализирует плату и определена в файле `bsp.c`.

(14) Функция `QF_init()` инициализирует компонент QF и лежащую в его основе ОСРВ/ядро, если такое программное обеспечение используется. Вам нужно вызвать `QF_init()` перед вызовом любых сервисов QF.

(15,16) Функция `QF_poolInit()` инициализирует пулы событий. Параметрами этой функции являются указатель на хранилище пула событий, размер этого хранилища,

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 15
и размер блока этого пула. Вы можете вызывать эту функцию до трех раз для инициализации до трех пулов событий. Последующие вызовы `QF_poolInit()` должны производиться в порядке возрастания размера блока. Например, пул с малым размером блока должен быть инициализирован до пула со средним размером блока.

(17) Функция `QF_psInit()` инициализирует механизм доставки событий по подписке (publish-subscribe) в QF. Параметрами этой функции являются указатель на массив списка подписчиков и размер этого массива.

Вспомогательный макрос `Q_DIM(a)` предоставляет размер одномерного массива `a[]`, вычисленный как `sizeof(a)/sizeof(a[0])`, что является константой времени компиляции. Использование этого макроса упрощает код, потому что позволяет мне избавиться от многих констант `#define`, которые в противном случае мне пришлось бы предоставлять для размеров различных массивов. Я могу просто жестко задать размер прямо в определении массива, что является единственным местом, где я его указываю. Затем я использую макрос `Q_DIM()` всякий раз, когда мне нужен этот размер в коде.

(18-20) Функция `QActive_start()` сообщает фреймворку QF начать управление активным объектом как частью приложения. Функция принимает следующие параметры: указатель на структуру активного объекта, приоритет активного объекта, указатель на его очередь событий, размер (длину) этой очереди и три других параметра, которые я объясню в Главе 7 (на данный момент они не имеют значения). Приоритеты активных объектов в QF нумеруются от 1 до `QF_MAX_ACTIVE` включительно, где более высокий номер приоритета означает более высокую срочность активного объекта. Константа `QF_MAX_ACTIVE` определена в заголовочном файле порта QF `qf_port.h` и в настоящее время не может превышать 63.

Мне нравится хранить код и данные каждого активного объекта строго инкапсулированными в его собственном C-файле. Например, весь код и данные для активного объекта `Ship` инкапсулированы в файле `ship.c`, а внешний интерфейс состоит из функции `Ship_ctor()` и указателя `AO_Ship`.

(21) На этом этапе вы предоставили фреймворку все хранилища и информацию, необходимые для управления вашим приложением. Последнее, что вы должны сделать, это вызвать функцию `QF_run()`, чтобы передать управление фреймворку.

После вызова `QF_run()` фреймворк полностью контролирует ситуацию. Фреймворк выполняет приложение, вызывая ваш код, а не наоборот. Функция `QF_run()` никогда не возвращает управление обратно в `main()`. В DOS-версии

***

16
Глава 1
игры "Fly 'n' Shoot" вы можете завершить приложение, нажав клавишу `Esc`, в этом случае `QF_run()` выйдет в DOS, но не в `main()`. Во встраиваемой системе, такой как плата Stellaris, `QF_run()` работает вечно или до тех пор, пока не будет отключено питание, в зависимости от того, что наступит раньше.

> **ПРИМЕЧАНИЕ**
> Для лучшей кросс-платформенной переносимости исходный код последовательно использует соглашение об окончании строки UNIX (строки завершаются только LF, символом 0xA). Это соглашение, по-видимому, работает для всех компиляторов C/C++ и кросс-компиляторов, включая устаревшие инструменты эпохи DOS. В отличие от этого, соглашение об окончании строки DOS/Windows (строки завершаются парой символов CR,LF или 0xD,0xA) известно тем, что вызывает проблемы на UNIX-подобных платформах, особенно в многострочных макросах препроцессора.

## 1.4 Проектирование игры "Fly 'n' Shoot"
Чтобы продолжить объяснение приложения "Fly 'n' Shoot", мне нужно перейти на уровень проектирования. На этом этапе мне нужно объяснить, как приложение было разложено на активные объекты и как эти объекты обмениваются событиями для совместного обеспечения функциональности игры "Fly 'n' Shoot".

В общем, декомпозиция задачи на активные объекты нетривиальна. Как и при любой декомпозиции, ваша цель — достичь как можно более слабой связи между компонентами активных объектов (в идеале, без совместного использования каких-либо ресурсов), и вы также стремитесь минимизировать коммуникацию с точки зрения частоты и размера обмениваемых событий.

В случае игры "Fly 'n' Shoot" мне сначала нужно определить все объекты с реактивным поведением (т.е. со стейт-машиной). Я применил простейшую объектно-ориентированную технику определения объектов, которая заключается в выборе часто используемых существительных в спецификации задачи. Из Раздела 1.2 я определил `Ship` (Корабль), `Missile` (Ракета), `Mines` (Мины) и `Tunnel` (Туннель). Однако не каждая стейт-машина в системе должна быть активным объектом (с отдельным контекстом задачи, очередью событий и уникальным уровнем приоритета), и их слияние является допустимым вариантом, когда требуется производительность или экономия места. В качестве примера этой идеи я в итоге объединил `Мины` в активный объект `Туннель`, при этом сохранив `Мины` как независимые компоненты стейт-машины активного объекта `Туннель`. Поступая так, я применил паттерн проектирования "Ортогональный компонент", описанный в Главе 5.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 17
Следующим шагом в проектировании событийно-управляемого приложения является назначение обязанностей и ресурсов идентифицированным активным объектам. Общая стратегия проектирования для избежания совместного использования ресурсов заключается в инкапсуляции каждого ресурса внутри выделенного активного объекта и предоставлении этому объекту возможности управлять ресурсом для остальной части приложения. Таким образом, вместо прямого совместного использования ресурса, остальная часть приложения совместно использует выделенный активный объект через события.

Так, например, я решил возложить на активный объект `Tunnel` ответственность за дисплей. Другие активные объекты и компоненты стейт-машин, такие как `Ship`, `Missile` и `Mines`, не рисуют на дисплее напрямую, а вместо этого отправляют события объекту `Tunnel` с запросом на отрисовку битовых карт `Ship`, `Missile` или `Mine` по предоставленным координатам (x, y) дисплея.

С некоторым пониманием обязанностей и распределения ресурсов между активными объектами я могу перейти к разработке различных сценариев обмена событиями между объектами. Возможно, лучшим инструментом для помощи в процессе мышления на этом этапе является **диаграмма последовательности UML**, такая как диаграмма, изображенная на Рисунке 1.4. Эта конкретная диаграмма последовательности показывает наиболее распространенные сценарии обмена событиями в игре "Fly 'n' Shoot" (основные варианты использования, если хотите). Раздел объяснений, следующий сразу за диаграммой, освещает интересные моменты.

> **ПРИМЕЧАНИЕ**
> Диаграмма последовательности UML, такая как на Рисунке 1.4, имеет два измерения. Горизонтально расположенные прямоугольники представляют различные объекты, участвующие в сценарии, тогда как жирные рамки указывают на активные объекты. Как обычно в UML, имя объекта подчеркнуто. Время течет вниз по странице вдоль вертикальных пунктирных линий, исходящих от объектов. События представлены как горизонтальные стрелки, начинающиеся от отправляющего объекта и заканчивающиеся на принимающем объекте. Опционально, тонкие прямоугольники вокруг линий экземпляров указывают на фокус управления.

> **ПРИМЕЧАНИЕ**
> Для объяснения диаграмм я ставлю номера в скобках у интересных элементов диаграммы. Затем я использую эти метки в левом поле раздела объяснений, который сразу следует за диаграммой. Иногда, чтобы однозначно сослаться на конкретный элемент диаграммы из разделов текста, отличных от раздела объяснений, я использую полную ссылку, состоящую из номера рисунка, за которым следует метка. Например, Рисунок 1.4(12) относится к элементу (12) на Рисунке 1.4.

***

18
Глава 1

**(Изображение: Диаграмма последовательности UML для игры "Fly 'n' Shoot")**

Участники: `Player` (Игрок), `QP` (фреймворк), `Ship` (Корабль), `Missile` (Ракета), `Tunnel` (Туннель), `Mine[n]` (Мина)

(1) `TIME_TICK` от QP ко всем активным объектам
(2) `Ship` отправляет `SHIP_IMG(x,y,bmp)` в `Tunnel`
(3) `Missile` игнорирует `TIME_TICK`
(4) `Tunnel` обрабатывает `TIME_TICK` и отправляет его всем `Mine[n]`
(5) `Mine[n]` отправляет `MINE_IMG` в `Tunnel`
(6) `Tunnel` получает `SHIP_IMG` и отправляет его всем `Mine[n]`
(7) `Mine[n]` обрабатывает `SHIP_IMG`

(8) `PLAYER_TRIGGER` от QP к `Ship` и `Tunnel`
(9) `Ship` отправляет `MISSILE_FIRE(x,y)` в `Missile`
(10) `Tunnel` обрабатывает `PLAYER_TRIGGER`

(11) `Missile` обрабатывает `MISSILE_FIRE`
(12) `TIME_TICK` приходит снова. `Missile` теперь отправляет `MISSILE_IMG` в `Tunnel`. `Tunnel` отправляет `MISSILE_IMG` всем `Mine[n]`.
(13) `Mine[n]` обнаруживает столкновение и отправляет `HIT_MINE(type)` в `Missile`.
(14) `Missile` обрабатывает `HIT_MINE` и отправляет `DESTROYED_MINE(type)` в `Ship`.
(15) `Ship` обрабатывает `DESTROYED_MINE`.

(16) `PLAYER_SHIP_MOVE(x,y)` от Player к `Ship`.

(17) Позже, `Ship` отправляет `SHIP_IMG`. `Tunnel` обнаруживает столкновение со стеной и отправляет `HIT_WALL` в `Ship`.
(18) `Ship` обрабатывает `HIT_WALL`.

**Рисунок 1.4:** Диаграмма последовательности игры "Fly 'n' Shoot".

(1) `TIME_TICK` — самое важное событие в игре. Это событие генерируется фреймворком QF из прерывания системного таймера с частотой 30 раз в секунду, что необходимо для плавной анимации дисплея. Поскольку событие `TIME_TICK` представляет интерес практически для всех объектов в приложении, оно **публикуется** фреймворком для всех активных объектов. (Доставка событий по подписке в QF описана в Главе 6.)

(2) При получении события `TIME_TICK` объект `Ship` продвигает свою позицию на один шаг и отправляет событие `SHIP_IMG(x, y, bmp)` объекту `Tunnel`.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 19
Событие `SHIP_IMG` имеет параметры `x` и `y`, которые являются координатами корабля на дисплее, а также номер растрового изображения `bmp` для отрисовки по этим координатам.

(3) Объект `Missile` еще не в полете, поэтому он просто игнорирует событие `TIME_TICK` в этот раз.

(4) Объект `Tunnel` выполняет самую тяжелую работу для события `TIME_TICK`. Во-первых, `Tunnel` перерисовывает весь дисплей из текущего буфера кадра. Это действие, выполняемое 30 раз в секунду, создает иллюзию анимации дисплея. Затем `Tunnel` очищает буфер кадра и начинает заполнять его снова для следующего кадра. `Tunnel` продвигает стенки туннеля на один шаг и копирует их в буфер кадра. `Tunnel` также отправляет событие `TIME_TICK` всем своим компонентам-стейт-машинам `Mine`.

(5) Каждая `Mine` продвигает свою позицию на один шаг и отправляет событие `MINE_IMG(x, y, bmp)` в `Tunnel`, чтобы отрисовать соответствующее растровое изображение `Mine` в позиции (x, y) в текущем буфере кадра. Мины типа 1 отправляют номер растрового изображения `MINE1_BMP`, тогда как мины типа 2 отправляют `MINE2_BMP`.

(6) При получении события `SHIP_IMG(x, y, bmp)` от `Ship`, объект `Tunnel` отрисовывает указанное растровое изображение в буфере кадра и проверяет наличие столкновения между растровым изображением корабля и стенками туннеля. `Tunnel` также отправляет оригинальное событие `SHIP_IMG(x, y, bmp)` всем активным `Mines`.

(7) Каждая `Mine` определяет, находится ли `Ship` в столкновении с этой миной.

(8) Событие `PLAYER_TRIGGER` генерируется, когда Игрок надежно нажимает кнопку (нажатие кнопки обработано с подавлением дребезга). Это событие публикуется фреймворком QF и доставляется объектам `Ship` и `Tunnel`, которые оба подписаны на событие `PLAYER_TRIGGER`.

(9) `Ship` генерирует событие `MISSILE_FIRE(x, y)` для объекта `Missile`. Параметрами этого события являются текущие координаты (x, y) `Ship`, которые являются начальной точкой для `Missile`.

(10) `Tunnel` также получает опубликованное событие `PLAYER_TRIGGER`, потому что `Tunnel` иногда должен начинать игру или завершать режим хранителя экрана на основе этого стимула.

(11) `Missile` реагирует на событие `MISSILE_FIRE(x, y)`, начиная полет, при этом он устанавливает свою начальную позицию из параметров события (x, y), полученных от `Ship`.

***

20
Глава 1
(12) На этот раз событие `TIME_TICK` приходит, когда `Missile` находится в полете. `Missile` отправляет событие `MISSILE_IMG(x, y, bmp)` в `Tunnel`.

(13) `Tunnel` отрисовывает растровое изображение `Missile` в текущем буфере кадра и отправляет событие `MISSILE_IMG(x, y, bmp)` всем `Mines`, чтобы `Mines` могли проверить столкновение с `Missile`. Это определение зависит от типа `Mine`. В этом сценарии конкретный объект `Mine[n]` обнаруживает попадание и отправляет событие `HIT_MINE(score)` в `Missile`. `Mine` предоставляет очки, заработанные за уничтожение этой конкретной мины, в качестве параметра этого события.

(14) `Missile` обрабатывает событие `HIT_MINE(score)`, становясь немедленно готовым к новому запуску, и позволяет `Mine` произвести взрыв. Поскольку я решил возложить на `Ship` ответственность за ведение счета, `Missile` также генерирует событие `DESTROYED_MINE(score)` для `Ship`, чтобы сообщить счет за уничтожение `Mine`.

(15) При получении события `DESTROYED_MINE(score)` `Ship` увеличивает счет на значение, полученное от `Missile`.

(16) Объект `Ship` обрабатывает событие `PLAYER_SHIP_MOVE(x, y)`, обновляя свою позицию из параметров события.

(17) Когда объект `Tunnel` в следующий раз обрабатывает событие `SHIP_IMG(x, y, bmp_id)`, он обнаруживает столкновение между `Ship` и стенкой туннеля. В этом случае он отправляет событие `HIT_WALL` в `Ship`.

(18) `Ship` отвечает на событие `HIT_WALL`, переходя в состояние "взрыва".

Несмотря на то, что диаграмма последовательности на Рисунке 1.4 показывает лишь некоторые выбранные сценарии игры "Fly 'n' Shoot", я надеюсь, что объяснения дают вам общее представление о том, как работает приложение. Что еще более важно, вы должны начать понимать общий мыслительный процесс, который лежит в основе проектирования событийно-управляемой системы с активными объектами и событиями.

## 1.5 Активные объекты в игре "Fly 'n' Shoot"
Я надеюсь, что анализ диаграммы последовательности на Рисунке 1.4 ясно показывает, что действия, выполняемые активным объектом, зависят как от получаемых им событий, так и от внутреннего режима объекта. Например, активный объект `Missile` обрабатывает событие `TIME_TICK` совершенно по-разному, когда `Missile` находится в полете (Рисунок 1.4(12)) по сравнению с тем, когда он не находится (Рисунок 1.4(3)).

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 21
Наиболее известным механизмом для обработки такого модального поведения являются **стейт-машины**, потому что стейт-машина делает поведение явно зависимым как от события, так и от состояния объекта. Глава 2 более подробно знакомит с концепциями UML стейт-машин. В этом разделе я даю краткое объяснение стейт-машин, связанных с каждым объектом в игре "Fly 'n' Shoot".

### 1.5.1 Активный объект Missile (Ракета)
Я начинаю со стейт-машины `Missile`, показанной на Рисунке 1.5, потому что она оказывается самой простой. Раздел объяснений, следующий сразу за диаграммой, освещает интересные моменты.

> **ПРИМЕЧАНИЕ**
> Диаграмма состояний UML, такая как на Рисунке 1.5, сохраняет общую форму традиционных диаграмм переходов состояний, где состояния представлены как узлы, а переходы — как дуги, соединяющие узлы. В нотации UML узлы состояний представлены в виде прямоугольников со скругленными углами. Имя состояния отображается жирным шрифтом в отсеке для имени в верхней части состояния. Опционально, прямо под именем, состояние может иметь отсек для внутренних переходов, отделенный от имени горизонтальной линией. Отсек для внутренних переходов может содержать действия входа (действия, следующие за зарезервированным символом "entry"), действия выхода (действия, следующие за зарезервированным символом "exit") и другие внутренние переходы (например, те, что вызываются `TIME_TICK` на Рисунке 1.5(3)). Переходы состояний представлены в виде стрелок, исходящих от границы исходного состояния и указывающих на границу целевого состояния. Как минимум, переход должен быть помечен инициирующим событием. Опционально, за триггером могут следовать параметры события, условие (guard) и список действий.

(1) Переход состояния, исходящий от черного шара, называется **начальным переходом**. Такой переход обозначает первое активное состояние после создания объекта стейт-машины. Начальный переход может иметь связанные с ним действия, которые в нотации UML перечисляются после косой черты (`/`). В данном конкретном случае стейт-машина `Missile` начинается в состоянии "armed" (наготове), а действия, выполняемые при инициализации, состоят в подписке на событие `TIME_TICK`. Подписка на событие означает, что фреймворк будет доставлять указанное событие активному объекту `Missile` каждый раз, когда это событие публикуется во фреймворке. Глава 7 описывает реализацию доставки событий по подписке в QF.

***

22
Глава 1

**(Изображение: Диаграмма состояний UML для объекта Missile)**

**Рисунок 1.5: Диаграмма стейт-машины Missile.**

**Состояния:**
- **armed (наготове):**
  - Начальный переход (1): `/ QActive_subscribe(me, TIME_TICK);`
  - Переход в `flying` по событию `MISSILE_FIRE(x, y)` (2): `/ me->x = e->x; me->y = e->y;`
- **flying (в полете):**
  - Внутренний переход по `TIME_TICK` (3) с условием `[me->x + GAME_MISSILE_SPEED_X < GAME_SCREEN_WIDTH]`:
    `/ me->x += GAME_MISSILE_SPEED_X; QActive_postFIFO(Tunnel, MISSILE_IMG(me->x, me->y, MISSILE_BMP));`
  - Переход в `armed` по `TIME_TICK` (4) с условием `[else]`
  - Переход в `armed` по `HIT_MINE(score)` (5): `/ QActive_postFIFO(Ship, DESTROYED_MINE(e->score));`
  - Переход в `exploding` по `HIT_WALL` (6)
- **exploding (взрывается):**
  - Действие входа (entry) (7): `/ me->exp_ctr = 0;`
  - Внутренний переход по `TIME_TICK` (8) с условием `[(me->x >= GAME_SPEED_X) && (me->exp_ctr < 16)]`:
    `/ me->x -= GAME_SPEED_X; ++me->exp_ctr; QActive_postFIFO(Tunnel, EXPLOSION_IMG(me->x + 3, me->y - 4, EXPLOSION0_BMP + (me->exp_ctr >> 2)));`
  - Переход в `armed` по `TIME_TICK` (9) с условием `[else]`

(2) Стрелка с меткой `MISSILE_FIRE(x, y)` обозначает переход состояния, то есть изменение состояния с "armed" на "flying". Событие `MISSILE_FIRE(x, y)` генерируется объектом `Ship`, когда Игрок запускает `Missile` (см. диаграмму последовательности на Рисунке 1.4). В событии `MISSILE_FIRE` `Ship` предоставляет `Missile` начальные координаты в параметрах события (x, y).

> **ПРИМЕЧАНИЕ**
> UML намеренно не указывает нотацию для действий. На практике действия часто пишутся на языке программирования, используемом для кодирования конкретной стейт-машины. Во всех диаграммах состояний в этой книге я предполагаю язык программирования C. Кроме того, в выражениях на C я ссылаюсь на члены данных, связанные с объектом стейт-машины, через префикс "`me->`" и на параметры события через префикс "`e->`". Например, действие "`me->x = e->x;`" означает, что внутреннему члену данных `x` активного объекта `Missile` присваивается значение параметра события `x`.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 23
(3) Имя события `TIME_TICK`, указанное в отсеке под именем состояния, обозначает **внутренний переход**. Внутренние переходы — это простые реакции на события, выполняемые без изменения состояния. Внутренний переход, как и обычный переход, может иметь **условие (guard)**, заключенное в квадратные скобки. Условие — это булево выражение, вычисляемое во время выполнения. Если условие истинно (TRUE), переход выполняется. В противном случае переход не выполняется, и никакие действия, указанные после косой черты (`/`), не выполняются. В данном конкретном случае условие проверяет, видна ли еще на экране x-координата, распространяемая со скоростью ракеты. Если да, то выполняются действия. Эти действия включают распространение позиции ракеты на один шаг и отправку события `MISSILE_IMG` с текущей позицией ракеты и номером растрового изображения `MISSILE_BMP` активному объекту `Tunnel`. Прямая отправка события активному объекту осуществляется с помощью функции QF `QActive_postFIFO()`, которую я обсуждаю в Главе 7.

(4) То же событие `TIME_TICK` с условием `[else]` обозначает обычный переход состояния с условием, дополняющим другое вхождение события `TIME_TICK` в том же состоянии. В этом случае переход `TIME_TICK` в состояние "armed" выполняется, если объект `Missile` вылетает за пределы экрана.

(5) Событие `HIT_MINE(score)` инициирует другой переход в состояние "armed". Действие, связанное с этим переходом, отправляет событие `DESTROYED_MINE` с параметром `e->score` объекту `Ship`, чтобы сообщить об уничтожении мины.

(6) Событие `HIT_WALL` инициирует переход в состояние "exploding" с целью анимации растровых изображений взрыва на дисплее.

(7) Метка "entry" обозначает **действие входа**, которое должно быть выполнено безусловно при входе в состояние "exploding". Это действие заключается в обнулении счетчика взрыва (`me->exp_ctr`) объекта `Missile`.

(8) Внутренний переход `TIME_TICK` защищен условием, что взрыв не выходит за пределы экрана и что счетчик взрыва меньше 16. Выполняемые действия включают распространение позиции взрыва и отправку события `EXPLOSION_IMG` активному объекту `Tunnel`. Обратите внимание, что растровое изображение взрыва меняется по мере увеличения счетчика взрыва.

(9) Обычный переход `TIME_TICK` с дополнительным условием меняет состояние обратно на "armed". Этот переход выполняется после завершения анимации взрыва.

***

24
Глава 1
### 1.5.2 Активный объект Ship (Корабль)
Стейт-машина активного объекта `Ship` показана на Рисунке 1.6. Эта стейт-машина вводит глубокую концепцию **иерархического вложения состояний**. Сила вложения состояний заключается в том, что оно предназначено для устранения повторений, которые в противном случае пришлось бы делать.

Одна из основных обязанностей активного объекта `Ship` — поддерживать текущую позицию `Ship`. На оригинальной плате EV-LM3S811 эта позиция определяется колесом потенциометра (см. Рисунок 1.2). Событие `PLAYER_SHIP_MOVE(x, y)` генерируется всякий раз, когда положение колеса меняется, как показано на диаграмме последовательности (Рисунок 1.4). Объект `Ship` должен всегда отслеживать положение колеса, что означает, что все состояния стейт-машины `Ship` должны обрабатывать событие `PLAYER_SHIP_MOVE(x, y)`.

В традиционном формализме конечных автоматов (FSM) вам пришлось бы повторять обновление позиции `Ship` от события `PLAYER_SHIP_MOVE(x, y)` в каждом состоянии. Но такие повторения раздули бы стейт-машину и, что более важно, представляли бы собой несколько точек обслуживания как на диаграмме, так и в коде. Такие повторения противоречат принципу **DRY (Don't Repeat Yourself — Не повторяйся)**, который жизненно важен для гибкого и поддерживаемого кода [Hunt+ 00].

Иерархическое вложение состояний решает эту проблему. Рассмотрим состояние "active", которое окружает все остальные состояния на Рисунке 1.6. Высокоуровневое состояние "active" называется **суперсостоянием** и является абстрактным в том смысле, что стейт-машина не может находиться непосредственно в этом состоянии, а только в одном из вложенных в него состояний, которые называются **подсостояниями** "active". Семантика UML, связанная с вложением состояний, предписывает, что любое событие сначала обрабатывается в контексте текущего активного подсостояния. Если подсостояние не может обработать событие, стейт-машина пытается обработать событие в контексте суперсостояния следующего уровня. Конечно, вложение состояний в UML не ограничивается только одним уровнем, и простое правило обработки событий применяется рекурсивно на любом уровне вложенности.

Конкретно для диаграммы стейт-машины `Ship`, показанной на Рисунке 1.6, предположим, что событие `PLAYER_SHIP_MOVE(x, y)` приходит, когда стейт-машина находится в состоянии "parked". Состояние "parked" не обрабатывает событие `PLAYER_SHIP_MOVE(x, y)`. В традиционной конечной стейт-машине на этом бы все и закончилось — событие `PLAYER_SHIP_MOVE(x, y)` было бы молча отброшено. Однако стейт-машина на Рисунке 1.6 имеет еще один слой — суперсостояние "active". Согласно семантике вложения состояний, это суперсостояние более высокого уровня обрабатывает событие `PLAYER_SHIP_MOVE(x, y)`, что именно и требуется. Точно такая же аргументация применяется для любого другого подсостояния суперсостояния "active", такого как "flying"

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 25
или "exploding", потому что ни одно из этих подсостояний не обрабатывает событие `PLAYER_SHIP_MOVE(x,y)`. Вместо этого, суперсостояние "active" обрабатывает это событие в одном единственном месте, без повторений.

**(Изображение: Иерархическая диаграмма состояний для объекта Ship)**

**Рисунок 1.6: Диаграмма стейт-машины Ship.**

**Суперсостояние `active`:**
- Начальный переход (1): `/ QActive_subscribe(me, TIME_TICK); QActive_subscribe(me, PLAYER_TRIGGER);`
- Внутренний переход по `PLAYER_SHIP_MOVE(x, y)` (3): `/ me->x = e->x; me->y = e->y;`
- **Подсостояние `parked` (начальное (2)):**
  - Переход в `flying` по `TAKE_OFF` (4)
- **Подсостояние `flying`:**
  - Действие входа (entry) (5): `/ me->score = 0; QActive_postFIFO(Tunnel, SCORE(me->score));`
  - Внутренний переход по `TIME_TICK` (6): `/ QActive_postFIFO(Tunnel, SHIP_IMG(me->x, me->y, SHIP_BMP)); ++me->score; if ((me->score % 10) == 0) QActive_postFIFO(Tunnel, SCORE(me->score));`
  - Внутренний переход по `PLAYER_TRIGGER` (7): `/ QActive_postFIFO(Missile, MISSLE_FIRE(me->x, me->y));`
  - Внутренний переход по `DESTROYED_MINE(score)` (8): `/ me->score += e->score;`
  - Переход в `exploding` по `HIT_WALL` (9)
  - Переход в `exploding` по `HIT_MINE(type)` (10)
- **Подсостояние `exploding` (11):**
  - Действие входа (entry): `/ me->exp_ctr = 0;`
  - Внутренний переход по `TIME_TICK` с условием `[me->exp_ctr < 16]`: `/ ++me->exp_ctr; QActive_postFIFO(Tunnel, EXPLOSION(me->x, me->y + SHIP_HEIGHT - 1, EXPLOSION0_BMP + (me->exp_ctr >> 2)));`
  - Переход из `exploding` (за пределы `active`) по `TIME_TICK` с условием `[else]` (12): `/ QActive_postFIFO(Table, GAME_OVER(me->score));`

(1) При начальном переходе стейт-машина `Ship` входит в суперсостояние "active" и подписывается на события `TIME_TICK` и `PLAYER_TRIGGER`.

(2) На каждом уровне вложенности суперсостояние может иметь частный начальный переход, который обозначает активное подсостояние после прямого входа в суперсостояние. Здесь

***

26 Глава 1
начальный переход состояния "active" обозначает подсостояние "parked" как начальное активное подсостояние.

(3) Суперсостояние "active" обрабатывает событие `PLAYER_SHIP_MOVE(x, y)` как внутренний переход, в котором оно обновляет внутренние члены данных `me->x` и `me->y` из параметров события `e->x` и `e->y` соответственно.

(4) Событие `TAKE_OFF` инициирует переход в состояние "flying". Это событие генерируется объектом `Tunnel`, когда Игрок начинает игру (см. описание игры в Разделе 1.2).

(5) Действия входа в "flying" включают обнуление члена данных `me->score` и отправку события `SCORE` с параметром `me->score` активному объекту `Tunnel`.

(6) Внутренний переход `TIME_TICK` вызывает отправку события `SHIP_IMG` с текущей позицией `Ship` и номером растрового изображения `SHIP_BMP` активному объекту `Tunnel`. Кроме того, счет увеличивается за выживание в течение еще одного тика времени. Наконец, когда счет "круглый" (делится на 10), он также отправляется активному объекту `Tunnel`. Это прореживание события `SCORE` выполняется просто для уменьшения пропускной способности коммуникации, поскольку активному объекту `Tunnel` нужно только дать пользователю приблизительное представление о текущем счете.

(7) Внутренний переход `PLAYER_TRIGGER` вызывает отправку события `MISSILE_FIRE` с текущей позицией `Ship` активному объекту `Missile`. Параметры (`me->x`, `me->y`) предоставляют `Missile` начальную позицию от `Ship`.

(8) Внутренний переход `DESTROYED_MINE(score)` вызывает обновление счета, хранящегося в `Ship`. Счет не отправляется в `Tunnel` на этом этапе, потому что следующий `TIME_TICK` отправит "округленный" счет, что достаточно для предоставления Игроку приближенного значения счета.

(9) Событие `HIT_WALL` инициирует переход в "exploding".

(10) Событие `HIT_MINE(type)` также инициирует переход в "exploding".

(11) Состояние "exploding" стейт-машины `Ship` очень похоже на состояние "exploding" `Missile` (см. Рисунок 1.5(7-9)).

(12) Переход `TIME_TICK[else]` выполняется, когда `Ship` заканчивает взрываться. При этом переходе объект `Ship` отправляет событие `GAME_OVER(me->score)` активному объекту `Tunnel`, чтобы завершить игру и отобразить итоговый счет Игроку.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 27
### 1.5.3 Активный объект Tunnel (Туннель)
Активный объект `Tunnel` имеет самую сложную стейт-машину, которая показана на Рисунке 1.7. В отличие от предыдущих диаграмм состояний, диаграмма на Рисунке 1.7 показывает только высокий уровень абстракции и опускает множество деталей, таких как большинство действий входа/выхода, внутренние переходы, условия или действия на переходах. Такой "увеличенный" вид всегда допустим в UML, потому что UML позволяет вам выбирать уровень детализации, который вы хотите включить в вашу диаграмму.

Стейт-машина `Tunnel` использует иерархию состояний более широко, чем стейт-машина `Ship` на Рисунке 1.6. Раздел объяснений, следующий сразу за Рисунком 1.7, освещает новые способы использования вложения состояний, а также новые элементы, еще не объясненные в других диаграммах состояний.

**(Изображение: Иерархическая диаграмма состояний для объекта Tunnel)**

**Рисунок 1.7: Диаграмма стейт-машины Tunnel.**

**Суперсостояние `active` (1):**
- Внутренний переход `MINE_DISABLED(mine_id)` (4): `/ me->mines[e->mine_id] = NULL;`
- Переход к конечному состоянию (3) по `PLAYER_QUIT` (2)
- **Подсостояние `demo` (начальное):**
  - Действие входа (entry) (5): `/ QTimeEvt_postIn(&me->screenTimeEvt, me, BSP_TICKS_PER_SEC*20);`
  - Действие выхода (exit) (6): `/ QTimeEvt_disarm(&me->screenTimeEvt);`
  - Переход в `playing` по `PLAYER_TRIGGER`
  - Переход в `screen_saver` по `SCREEN_TIMEOUT` (7)
- **Подсостояние `playing`:**
  - Переход в `game_over` по `GAME_OVER`
- **Подсостояние `game_over`:**
  - Переход в `demo` по `SCREEN_TIMEOUT`
- **Суперсостояние `screen_saver`:**
  - Переход в `demo` по `PLAYER_TRIGGER` (8)
  - **Подсостояние `screen_saver_n_pixels` (начальное):**
    - Переход в `screen_saver_1_pixel` по `SCREEN_TIMEOUT`
  - **Подсостояние `screen_saver_1_pixel`**

***

28
Глава 1
(1) Начальный переход может указывать на подсостояние на любом уровне иерархии состояний, не обязательно только на следующем, более низком уровне. Здесь самый верхний начальный переход спускается на два уровня вниз к подсостоянию "demo".

(2) Суперсостояние "active" обрабатывает событие `PLAYER_QUIT` как переход к конечному состоянию (см. объяснение элемента (3)). Обратите внимание, что переход `PLAYER_QUIT` применяется ко всем подсостояниям, прямо или транзитивно вложенным в суперсостояние "active". Поскольку переход состояния всегда включает выполнение всех действий выхода из состояний, высокоуровневый переход `PLAYER_QUIT` гарантирует правильную очистку, специфичную для текущего контекста состояния, какое бы подсостояние ни было активным в момент прихода события `PLAYER_QUIT`.

(3) **Конечное состояние** в нотации UML обозначается символом "яблочко" и обычно указывает на уничтожение объекта стейт-машины. В данном случае событие `PLAYER_QUIT` указывает на завершение игры.

(4) Событие `MINE_DISABLED(mine_id)` обрабатывается на высоком уровне состояния "active", что означает, что этот внутренний переход применяется ко всей подмашине, вложенной в суперсостояние "active". (См. также обсуждение объекта `Mine` в следующем разделе.)

(5) Действие входа в состояние "demo" запускает событие времени экрана (таймер) `me->screenTimeEvt` на истечение через 20 секунд. **События времени** выделяются приложением, но управляются фреймворком QF. QF предоставляет функции для установки события времени, такие как `QTimeEvt_postIn()` для однократного тайм-аута и `QTimeEvt_postEvery()` для периодических событий времени. Установка события времени, по сути, говорит фреймворку QF, например: "Разбуди меня через 20 секунд". Затем QF отправляет событие времени (в данном случае событие `me->screenTimeEvt`) активному объекту после запрошенного количества тактов таймера. Главы 6 и 7 подробно рассказывают о событиях времени.

(6) Действие выхода из состояния "demo" отключает событие времени `me->screenTimeEvt`. Эта очистка необходима, когда из состояния можно выйти по другому событию, отличному от события времени, такому как переход `PLAYER_TRIGGER`.

(7) Переход `SCREEN_TIMEOUT` в "screen_saver" инициируется истечением события времени `me->screenTimeEvt`. Сигнал `SCREEN_TIMEOUT` присваивается этому событию времени при инициализации и не может быть изменен позже.

(8) Переход, инициируемый `PLAYER_TRIGGER`, применяется в равной степени к двум подсостояниям суперсостояния "screen_saver".

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 29
### 1.5.4 Компоненты Mine (Мины)
Мины также моделируются как иерархические стейт-машины, но не являются активными объектами. Вместо этого, Мины являются компонентами активного объекта `Tunnel` и разделяют его очередь событий и уровень приоритета. Активный объект `Tunnel` общается с компонентами `Mine` **синхронно**, напрямую отправляя им события через функцию `QHsm_dispatch()`. Мины общаются с `Tunnel` и всеми другими активными объектами **асинхронно**, отправляя события в их очереди событий через функцию `QActive_postFIFO()`.

> **ПРИМЕЧАНИЕ**
> Активные объекты обмениваются событиями асинхронно, что означает, что отправитель события просто помещает событие в очередь событий принимающего активного объекта, не дожидаясь завершения обработки события. В отличие от этого, синхронная обработка событий соответствует вызову функции (например, `QHsm_dispatch()`), которая обрабатывает событие в потоке выполнения вызывающей стороны.

Как показано на Рисунке 1.8, `Tunnel` поддерживает член данных `mines[]`, который является массивом указателей на иерархические стейт-машины (`QHsm *`). Каждый из этих указателей может указывать либо на объект `Mine1`, либо на объект `Mine2`, либо на `NULL`, если запись не используется. Обратите внимание, что `Tunnel` "знает" о `Mines` только как о общих стейт-машинах (указатели на структуру `QHsm`, определенную в QP). `Tunnel` отправляет события `Mines` единообразно, не делая различий между разными типами `Mines`. Тем не менее, каждая стейт-машина `Mine` обрабатывает события своим специфическим образом. Например, `Mine` типа 2 проверяет столкновение с `Missile` иначе, чем с `Ship`, тогда как `Mine` типа 1 обрабатывает оба одинаково.

**(Изображение: Диаграмма, показывающая, как объект Tunnel управляет двумя типами мин)**

**Рисунок 1.8:** Активный объект Tunnel управляет двумя типами мин.

(Диаграмма показывает, что массив `QHsm *mines[]` в объекте `Tunnel` содержит указатели, которые могут указывать на экземпляры из массивов `Mine1 mines1[]` или `Mine2 mines2[]`, или быть `NULL`).

***

30
Глава 1
> **ПРИМЕЧАНИЕ**
> Последний пункт на самом деле очень интересен. Отправка одного и того же события разным объектам `Mine` приводит к разному поведению, специфичному для типа `Mine`, что в ООП известно как **полиморфизм**. Я расскажу об этом подробнее в Главе 3.

Каждый объект `Mine` является достаточно автономным. `Mine` поддерживает свою собственную позицию и отвечает за информирование объекта `Tunnel` всякий раз, когда `Mine` уничтожается или выходит за пределы экрана. Эта информация жизненно важна для объекта `Tunnel`, чтобы он мог отслеживать неиспользуемые `Mines`.

Рисунок 1.9 показывает иерархическую стейт-машину `Mine2`. `Mine1` очень похожа, за исключением того, что она использует одно и то же растровое изображение для проверки столкновений как с `Missile`, так и с `Ship`.

(1) `Mine` начинает в состоянии "unused" (не используется).

(2) Объект `Tunnel` устанавливает `Mine`, отправляя событие `MINE_PLANT(x, y)` в `Mine`. `Tunnel` предоставляет координаты (x, y) в качестве исходной позиции `Mine`.

(3) Когда `Mine` выходит за пределы экрана, стейт-машина переходит в "unused".

(4) Когда `Mine` сталкивается с `Ship`, стейт-машина переходит в "unused".

(5) Когда `Mine` заканчивает взрываться, стейт-машина переходит в "unused".

(6) Когда `Mine` перерабатывается объектом `Tunnel`, стейт-машина переходит в "unused".

(7) Действие выхода (exit action) в состоянии "used" отправляет событие `MINE_DISABLED(mine_id)` активному объекту `Tunnel`. Через это событие `Mine` информирует `Tunnel`, что она становится неактивной, чтобы `Tunnel` мог обновить свой массив `mines[]` (см. также Рисунок 1.9(4)). Параметр `mine_id` события становится индексом в массиве `mines[]`. Обратите внимание, что генерация события `MINE_DISABLED(mine_id)` в действии выхода из "used" намного безопаснее и более поддерживаема, чем повторение этого действия в каждом отдельном переходе (3), (4), (5) и (6).

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 31

**(Изображение: Иерархическая диаграмма состояний для объекта Mine2)**

**Рисунок 1.9: Диаграмма стейт-машины Mine2.**

**Состояния:**
- **unused (не используется):**
  - Начальное состояние (1)
  - Переход из `used` по `MINE_RECYCLE` (6)
  - Переход в `used` по `MINE_PLANT(x, y)` (2): `/ me->x = e->x; me->y = e->y;`
- **Суперсостояние `used`:**
  - Действие выхода (exit) (7): `/ QActive_postFIFO(Tunnel, MINE_DISABLED(MINE_ID(me)));`
  - **Подсостояние `planted` (начальное):**
    - Внутренний переход по `TIME_TICK` (3) с условием `[me->x + GAME_MISSILE_SPEED_X < GAME_SCREEN_WIDTH]`: `/ me->x += GAME_MISSILE_SPEED_X; postFIFO(Tunnel, MISSILE_IMG(me->x, me->y, MISSILE_BMP));`
    - Переход в `unused` по `TIME_TICK` с условием `[else]`
    - Переход в `unused` по `SHIP_IMG` (4) с условием `[do_bitmaps_overlap(...)]`: `/ postFIFO(Ship, HIT_MINE(2));`
    - Переход в `exploding` по `MISSILE_IMG` с условием `[do_bitmaps_overlap(...)]`: `/ postFIFO(Missile, DESTROYED_MINE(45));`
  - **Подсостояние `exploding`:**
    - Действие входа (entry): `/ me->exp_ctr = 0;`
    - Внутренний переход по `TIME_TICK` с условием `[(me->x >= GAME_SPEED_X) && (me->exp_ctr < 16)]`: `/ me->x -= GAME_SPEED_X; ++me->exp_ctr; postFIFO(Tunnel, EXPLOSION(...));`
    - Переход в `unused` по `TIME_TICK` с условием `[else]` (5)

***

32
Глава 1
## 1.6 События в игре "Fly 'n' Shoot"
Ключевые события в игре "Fly 'n' Shoot" были определены на диаграмме последовательности на Рисунке 1.4. Другие события были придуманы на этапе проектирования стейт-машины. В любом случае, вы, должно быть, заметили, что события на самом деле состоят из двух частей. Часть события, называемая **сигналом**, передает тип происшествия (что произошло). Например, сигнал `TIME_TICK` передает приход тика времени, тогда как сигнал `PLAYER_SHIP_MOVE` передает, что игрок хочет переместить корабль. Событие также может содержать дополнительную количественную информацию о происшествии в виде **параметров события**. Например, сигнал `PLAYER_SHIP_MOVE` сопровождается параметрами (x, y), которые содержат количественную информацию о том, куда именно переместить корабль.

В QP события представлены как экземпляры структуры `QEvent`, предоставляемой фреймворком. В частности, структура `QEvent` содержит член `sig` для представления сигнала этого события. Параметры события добавляются в процессе наследования, как описано во врезке "Одиночное наследование в C".

> **ОДИНОЧНОЕ НАСЛЕДОВАНИЕ В C**
>
> **Наследование** — это возможность создавать новые структуры на основе существующих для повторного использования и организации кода. Вы можете реализовать одиночное наследование в C очень просто, буквально встраивая базовую структуру как первый член производной структуры. Например, Рисунок 1.10(A) показывает структуру `ScoreEvt`, унаследованную от базовой структуры `QEvent` путем встраивания экземпляра `QEvent` в качестве первого члена `ScoreEvt`. Чтобы эта идиома лучше выделялась, я всегда называю член базовой структуры `super`.

**(Изображение: Диаграмма, иллюстрирующая одиночное наследование в C)**

**Рисунок 1.10:** (A) Определение структур в C, (B) выравнивание в памяти, и (C) диаграмма классов UML.

**A (Код):**
```c
typedef struct QEventTag {
    QSignal sig;
} QEvent;

typedef struct ScoreEvtTag {
    QEvent super;
    uint16_t score;
} ScoreEvt;
```

**B (Память):**
Экземпляр `ScoreEvt` (`me`):
- `super` (экземпляр базовой структуры)
- `score` (добавленные члены в производной структуре)

**C (UML):**
Класс `QEvent` { `sig: QSignal` }
^ (наследование)
Класс `ScoreEvt` { `score: uint16_t` }

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 33
Как показано на Рисунке 1.10(B), такое вложение структур всегда выравнивает член данных `super` в начале каждого экземпляра производной структуры, что фактически гарантируется стандартом C. В частности, WG14/N1124 Раздел 6.7.2.1.13 гласит: "...Указатель на объект структуры, соответствующим образом преобразованный, указывает на его начальный член. Внутри объекта структуры может быть безымянное заполнение, но не в его начале" [ISO/IEC 9899:TC2]. Выравнивание позволяет вам рассматривать указатель на производную структуру `ScoreEvt` как указатель на базовую структуру `QEvent`. Все это легально, переносимо и гарантировано стандартом C. Следовательно, вы всегда можете безопасно передать указатель на `ScoreEvt` любой функции C, которая ожидает указатель на `QEvent`. (Чтобы быть строго корректным в C, вы должны явно привести этот указатель. В ООП такое приведение называется *upcasting* и всегда безопасно.) Таким образом, все функции, предназначенные для структуры `QEvent`, автоматически доступны для структуры `ScoreEvt`, а также для других структур, унаследованных от `QEvent`. Рисунок 1.10(C) показывает диаграмму классов UML, изображающую отношение наследования между структурами `ScoreEvt` и `QEvent`.

QP довольно широко использует одиночное наследование не только для вывода событий с параметрами, но и для вывода стейт-машин и активных объектов. Конечно, C++ версия QP использует встроенную поддержку C++ для наследования классов, а не "вывод структур". Вы увидите больше примеров наследования позже в этой главе и на протяжении всей книги.

Поскольку события явно используются совместно большинством компонентов приложения, удобно объявить их в отдельном заголовочном файле `game.h`, показанном в Листинге 1.2. Раздел объяснений, следующий сразу за листингом, освещает интересные моменты.

**Листинг 1.2 Сигналы, структуры событий и интерфейсы активных объектов, определенные в файле game.h**
```c
(1) enum GameSignals {
                                 /* сигналы, используемые в игре */
(2) TIME_TICK_SIG = Q_USER_SIG,  /* публикуется из ISR таймера */
    PLAYER_TRIGGER_SIG,        /* публикуется Игроком (ISR) для запуска Ракеты */
    PLAYER_QUIT_SIG,           /* публикуется Игроком (ISR) для выхода из игры */
    GAME_OVER_SIG,             /* публикуется Кораблем, когда он заканчивает взрываться */
                               /* вставьте другие публикуемые сигналы сюда... */
(3) MAX_PUB_SIG,                 /* последний публикуемый сигнал */

    PLAYER_SHIP_MOVE_SIG,      /* отправляется Игроком (ISR) Кораблю для его перемещения */
    BLINK_TIMEOUT_SIG,         /* сигнал для тайм-аута мигания Туннеля */
    SCREEN_TIMEOUT_SIG,        /* сигнал для тайм-аута экрана Туннеля */
    TAKE_OFF_SIG,              /* от Туннеля к Кораблю, чтобы разрешить взлет */
    HIT_WALL_SIG,              /* от Туннеля к Кораблю, когда Корабль ударяется о стену */
    HIT_MINE_SIG,              /* от Мины к Кораблю или Ракете, когда она попадает в мину */
    SHIP_IMG_SIG,              /* от Корабля к Туннелю для отрисовки и проверки на попадания */
    MISSILE_IMG_SIG,           /* от Ракеты к Туннелю для отрисовки и проверки на попадания */
    MINE_IMG_SIG,              /* отправляется Миной в Туннель для отрисовки мины */
```
*Продолжение на следующей странице*

***

34
Глава 1
```c
    MISSILE_FIRE_SIG,          /* отправляется Кораблем Ракете для выстрела */
    DESTROYED_MINE_SIG,      /* от Ракеты к Кораблю, когда Ракета уничтожила Мину */
    EXPLOSION_SIG,             /* от любого взрывающегося объекта для отрисовки взрыва */
    MINE_PLANT_SIG,            /* от Туннеля к Мине для ее установки */
    MINE_DISABLED_SIG,         /* от Мины к Туннелю, когда она становится неактивной */
    MINE_RECYCLE_SIG,          /* отправляется Туннелем Мине для ее переработки */
    SCORE_SIG,                 /* от Корабля к Туннелю для корректировки уровня игры на основе счета */
                               /* вставьте другие сигналы сюда ... */
(4) MAX_SIG                    /* последний сигнал (всегда оставлять последним) */
};

(5) typedef struct ObjectPosEvtTag {
(6)   QEvent super;             /* расширяем класс QEvent */
(7)   uint8_t x;                 /* x-позиция объекта */
(8)   uint8_t y;                 /* новая y-позиция объекта */
} ObjectPosEvt;

typedef struct ObjectImageEvtTag {
    QEvent super;             /* расширяем класс QEvent */
    uint8_t x;                 /* x-позиция объекта */
    int8_t y;                  /* y-позиция объекта */
    uint8_t bmp;               /* ID растрового изображения, представляющего объект */
} ObjectImageEvt;

typedef struct MineEvtTag {
    QEvent super;             /* расширяем класс QEvent */
    uint8_t id;                /* ID Мины */
} MineEvt;

typedef struct ScoreEvtTag {
    QEvent super;             /* расширяем класс QEvent */
    uint16_t score;            /* текущий счет */
} ScoreEvt;

/* непрозрачные указатели на активные объекты в приложении */
(9)  extern QActive * const AO_Tunnel;
(10) extern QActive * const AO_Ship;
(11) extern QActive * const AO_Missile;

/* "конструкторы" активных объектов */
(12) void Tunnel_ctor(void);
(13) void Ship_ctor(void);
(14) void Missile_ctor(void);
```

(1) В QP сигналы событий — это просто перечисленные константы. Размещение всех сигналов в одном перечислении особенно удобно для избежания случайного пересечения числовых значений разных сигналов.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 35
(2) Сигналы уровня приложения начинаются не с нуля, а смещены на константу `Q_USER_SIG`. Это связано с тем, что QP резервирует несколько самых низких сигналов для внутреннего использования и предоставляет константу `Q_USER_SIG` в качестве смещения, с которого могут начинаться сигналы пользовательского уровня. Также обратите внимание, что по соглашению я добавляю суффикс `_SIG` ко всем сигналам, чтобы я мог легко отличать сигналы от других констант. Я опускаю суффикс `_SIG` в диаграммах состояний, чтобы уменьшить загромождение.

(3) Константа `MAX_PUB_SIG` отделяет публикуемые сигналы от остальных. Механизм доставки событий по подписке потребляет некоторое количество ОЗУ, пропорциональное количеству публикуемых сигналов. Я экономлю некоторое количество ОЗУ, предоставляя QP нижний предел публикуемых сигналов (`MAX_PUB_SIG`), а не максимум всех сигналов, используемых в приложении. (См. также Листинг 1.1(9)).

(4) Последнее перечисление `MAX_SIG` указывает максимум всех сигналов, используемых в приложении.

(5) Структура события `ObjectPosEvt` определяет "класс" событий, которые передают позицию объекта на дисплее в параметрах события.

(6) Структура `ObjectPosEvt` наследуется от базовой структуры `QEvent`, как объяснено во врезке "Одиночное наследование в C".

(7,8) Структура `ObjectPosEvt` добавляет параметры `x` и `y`, которые являются координатами объекта на дисплее.

> **ПРИМЕЧАНИЕ**
> На протяжении всей этой книги я использую следующие стандартные целочисленные типы с точной шириной (WG14/N843 C99 Standard, Section 7.18.1.1) [ISO/IEC 9899:TC2]:
> 
> | Точный размер | Без знака | Со знаком |
> | :--- | :--- | :--- |
> | 8-бит | `uint8_t` | `int8_t` |
> | 16-бит | `uint16_t`| `int16_t` |
> | 32-бита | `uint32_t`| `int32_t` |
>
> Если ваш (до-стандартный) компилятор не предоставляет заголовочный файл `<stdint.h>`, вы всегда можете определить типы с точной шириной с помощью `typedef`, используя стандартные типы данных C, такие как `signed/unsigned char`, `short`, `int` и `long`.

***

36
Глава 1
(9-11) Эти глобальные указатели представляют активные объекты в приложении и используются для прямой отправки событий активным объектам. Поскольку указатели могут быть инициализированы во время компиляции, мне нравится объявлять их `const`, чтобы их можно было разместить в ПЗУ. Указатели на активные объекты "непрозрачны", потому что они не могут получить доступ ко всему активному объекту, а только к той части, которая унаследована от структуры `QActive`. Я расскажу об этом подробнее в следующем разделе.

(12-14) Эти функции выполняют раннюю инициализацию активных объектов в системе. Они играют роль статических "конструкторов", которые в C вам нужно вызывать явно, обычно в начале `main()`. (См. также Листинг 1.1(10-12).)

### 1.6.1 Генерация, отправка и публикация событий
Фреймворк QF поддерживает два типа асинхронного обмена событиями:

1. Простой механизм прямой **отправки** событий, поддерживаемый через функции `QActive_postFIFO()` и `QActive_postLIFO()`, где производитель события напрямую отправляет событие в очередь событий потребителя-активного объекта.

2. Более сложный механизм доставки событий по **публикации-подписке**, поддерживаемый через функции `QF_publish()` и `QActive_subscribe()`, где производители событий "публикуют" их во фреймворке, а фреймворк затем доставляет события всем активным объектам, которые "подписались" на эти события.

В QF любая часть системы, не обязательно только активные объекты, может производить события. Например, подпрограммы обработки прерываний (ISR) или драйверы устройств также могут производить события. С другой стороны, только активные объекты могут потреблять события, потому что только у активных объектов есть очереди событий.

> **ПРИМЕЧАНИЕ**
> QF также предоставляет "сырые" потокобезопасные очереди событий (struct QEQueue), которые также могут потреблять события. Эти "сырые" потокобезопасные очереди не могут блокироваться и предназначены для доставки событий в ISR или драйверы устройств. Обратитесь к Главе 7 для получения более подробной информации.

Самая важная характеристика управления событиями в QF заключается в том, что фреймворк передает только **указатели** на события, а не сами события. QF никогда не копирует

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 37
события по значению (политика "нулевого копирования"); даже в случае публикации событий, которая часто включает многоадресную рассылку одного и того же события нескольким подписчикам. Фактические экземпляры событий являются либо постоянными событиями, статически выделенными во время компиляции, либо динамическими событиями, выделенными во время выполнения из одного из пулов событий, которыми управляет фреймворк. Листинг 1.3 предоставляет примеры публикации статических событий и отправки динамических событий из ISR версии "Fly 'n' Shoot" для платы Stellaris (файл `<qp>\qpc\examples\cortex-m3\vanilla\iar\game-ev-lm3s811\bsp.c`). В Разделе 1.7.3 вы увидите другие примеры отправки событий из активных объектов в коде стейт-машины.

**Листинг 1.3 Генерация, отправка и публикация событий из ISR в bsp.c для платы Stellaris**
```c
(1) void ISR_SysTick(void) {
(2)   static QEvent const tickEvt = { TIME_TICK_SIG, 0 };
(3)   QF_publish(&tickEvt);  /* публикуем событие тика всем подписчикам */
(4)   QF_tick();             /* обрабатываем все установленные события времени */
}
/*..........................................................................*/
(5) void ISR_ADC(void) {
    static uint32_t adcLPS = 0;   /* Отфильтрованное значение АЦП */
    static uint32_t wheel = 0;    /* последняя позиция колеса */
    unsigned long tmp;

    ADCIntClear(ADC_BASE, 3);                   /* очищаем прерывание АЦП */
(6) ADCSequenceDataGet(ADC_BASE, 3, &tmp);    /* считываем данные с АЦП */

    /* фильтр нижних частот 1-го порядка: постоянная времени ~= 2^n выборок
     * TF = (1/2^n)/(z-((2^n-1)/2^n)),
     * например, n=3, y(k+1) = y(k) - y(k)/8 + x(k)/8 => y += (x - y)/8
     */
(7) adcLPS += (((int)tmp - (int)adcLPS + 4) >> 3); /* Фильтр нижних частот */

    /* вычисляем следующую позицию колеса */
(8) tmp = (((1 << 10) - adcLPS) * (BSP_SCREEN_HEIGHT - 2)) >> 10;

    if (tmp != wheel) { /* изменилась ли позиция колеса? */
(9)   ObjectPosEvt *ope = Q_NEW(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG);
(10)  ope->x = (uint8_t)GAME_SHIP_X; /* x-позиция фиксирована */
(11)  ope->y = (uint8_t)tmp;
(12)  QActive_postFIFO(AO_Ship, (QEvent *)ope); /* отправляем в АО Ship */
      wheel = tmp; /* сохраняем последнюю позицию колеса */
    }
}
```

***

38
Глава 1
(1) В случае платы Stellaris функция `ISR_SysTick()` обслуживает ISR системного таймера, генерируемый системным таймером Cortex-M3.

(2) Событие `TIME_TICK` никогда не меняется, поэтому его можно статически выделить только один раз. Это событие объявлено как `const`, что означает, что его можно разместить в ПЗУ. Список инициализаторов для этого события состоит из сигнала `TIME_TICK_SIG`, за которым следует ноль. Этот ноль информирует фреймворк QF о том, что это событие является статическим и никогда не должно быть возвращено в пул событий.

(3) ISR вызывает функцию фреймворка `QF_publish()`, которая принимает указатель на событие `tickEvt` для доставки всем подписчикам.

(4) ISR вызывает функцию `QF_tick()`, в которой фреймворк управляет установленными событиями времени.

(5) Функция `ISR_ADC()` обслуживает преобразования АЦП, которые в конечном итоге определяют положение корабля.

(6) ISR считывает данные из АЦП.

(7,8) К сырому значению АЦП применяется фильтр нижних частот, и вычисляется положение колеса потенциометра.

(9) Макрос QF `Q_NEW(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG)` динамически выделяет экземпляр события `ObjectPosEvt` из пула событий, управляемого QF. Макрос также выполняет связывание сигнала `PLAYER_SHIP_MOVE_SIG` с выделенным событием. Макрос `Q_NEW()` возвращает указатель на выделенное событие.

> **ПРИМЕЧАНИЕ**
> Событие `PLAYER_SHIP_MOVE(x, y)` является примером события с изменяющимися параметрами. В общем, такое событие не может быть выделено статически (как событие `TIME_TICK` в метке (2)), потому что оно может асинхронно измениться в следующий раз, когда выполнится ISR. Некоторые активные объекты в системе могут все еще ссылаться на событие через указатель, поэтому событие не должно меняться. Динамическое выделение событий в QF решает все подобные проблемы параллелизма, потому что каждый раз выделяется новое событие. Затем QF утилизирует динамические события после того, как определит, что все активные объекты закончили доступ к ним.

(10,11) Присваиваются параметры `x` и `y` события.

(12) Динамическое событие отправляется напрямую активному объекту `Ship`.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 39
## 1.7 Кодирование иерархических стейт-машин
Вопреки распространенным заблуждениям, вам не нужны большие инструменты автоматизации проектирования для перевода иерархических стейт-машин (UML statecharts) в эффективный и легко поддерживаемый код на C или C++. В этом разделе объясняется, как вручную закодировать стейт-машину `Ship` из Рисунка 1.6 с помощью фреймворка реального времени QF и иерархического процессора QEP, который также является частью событийно-управляемой платформы QP. Как только вы узнаете, как кодировать эту стейт-машину, вы будете знать, как кодировать их все.

Исходный код для стейт-машины `Ship` находится в файле `ship.c`, расположенном либо в DOS-версии, либо в Stellaris-версии игры "Fly 'n' Shoot". Я разобью объяснение этого файла на три шага.

### 1.7.1 Шаг 1: Определение структуры Ship
На первом шаге вы определяете структуру данных `Ship`. Так же, как и в случае с событиями, вы используете наследование для вывода структуры `Ship` из структуры фреймворка `QActive` (см. врезку "Одиночное наследование в C"). Создание этого отношения наследования связывает структуру `Ship` с фреймворком QF.

Основная обязанность базовой структуры `QActive` — хранить информацию о текущем активном состоянии стейт-машины, а также об очереди событий и уровне приоритета активного объекта `Ship`. Фактически, `QActive` сама наследуется от более простой структуры QEP `QHsm`, которая представляет только текущее активное состояние иерархической стейт-машины. Помимо этой информации, почти каждая стейт-машина должна хранить и другую информацию "расширенного состояния". Например, объект `Ship` отвечает за поддержание позиции `Ship`, а также за накопленный в игре счет. Вы предоставляете эту дополнительную информацию с помощью членов данных, перечисленных после члена базовой структуры `super`, как показано в Листинге 1.4.

**Листинг 1.4 Определение структуры Ship в файле ship.c**
```c
(1) #include "qp_port.h"      /* порт QP */
(2) #include "bsp.h"          /* Пакет поддержки платы */
(3) #include "game.h"         /* это приложение */
    /* локальные объекты -------------------------------------------------*/
(4) typedef struct ShipTag {
(5)   QActive super;          /* наследуемся от структуры QActive */
(6)   uint8_t x;              /* x-координата позиции Корабля на дисплее */
(7)   uint8_t y;              /* y-координата позиции Корабля на дисплее */
(8)   uint8_t exp_ctr;        /* счетчик взрыва, используется для анимации взрывов */
```
*Продолжение на следующей странице*

***

40
Глава 1
```c
(9)   uint16_t score;         /* текущий счет в игре */
(10) } Ship;                 /* имя, определенное через typedef, для структуры Ship */

    /* функции-обработчики состояний... */
(11) static QState Ship_active(Ship *me, QEvent const *e);
(12) static QState Ship_parked(Ship *me, QEvent const *e);
(13) static QState Ship_flying(Ship *me, QEvent const *e);
(14) static QState Ship_exploding(Ship *me, QEvent const *e);

(15) static QState Ship_initial(Ship *me, QEvent const *e);

(16) static Ship l_ship;     /* единственный экземпляр активного объекта Ship */

    /* глобальные объекты ------------------------------------------------*/
(17) QActive * const AO_ship = (QActive *)&l_ship; /* непрозрачный указатель на АО Ship */
```

(1) Каждый C-файл уровня приложения, использующий платформу QP, должен включать заголовочный файл `qp_port.h`.

(2) Заголовочный файл `bsp.h` содержит интерфейс к Пакету поддержки платы.

(3) Заголовочный файл `game.h` содержит объявления событий и других средств, общих для компонентов приложения (см. Листинг 1.2).

(4) Эта структура определяет активный объект `Ship`.

> **ПРИМЕЧАНИЕ**
> Мне нравится хранить активные объекты, и вообще все объекты стейт-машин (такие как `Mines`), строго инкапсулированными. Поэтому я не помещаю определения структур стейт-машин в заголовочные файлы; вместо этого я определяю их прямо в файле реализации, таком как `ship.c`. Таким образом, я могу быть уверен, что внутренние члены данных структуры `Ship` не известны никаким другим частям приложения.

(5) Структура активного объекта `Ship` наследуется от структуры фреймворка `QActive`, как описано во врезке "Одиночное наследование в C".

(6,7) Члены данных `x` и `y` представляют позицию `Ship` на дисплее.

(8) Член `exp_ctr` используется для управления анимацией взрыва (см. также состояние "exploding" на диаграмме состояний `Ship` на Рисунке 1.6).

(9) Член `score` хранит накопленный в игре счет.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 41
(10) Я использую `typedef` для определения более короткого имени `Ship`, эквивалентного `struct ShipTag`.

(11-14) Эти четыре функции называются **функциями-обработчиками состояний**, потому что они соответствуют один к одному состояниям стейт-машины `Ship`, показанной на Рисунке 1.6. Например, функция `Ship_active()` представляет состояние "active". Обработчик событий QEP вызывает функции-обработчики состояний для реализации семантики выполнения стейт-машины UML. Все функции-обработчики состояний имеют одинаковую сигнатуру. Функция-обработчик состояния принимает указатель на стейт-машину и указатель на событие в качестве аргументов и возвращает статус операции обратно обработчику событий — например, было ли событие обработано или нет. Тип возвращаемого значения `QState` функций-обработчиков состояний определен через `typedef` как `uint8_t` в заголовочном файле `<qp>\qpc\include\qep.h`.

> **ПРИМЕЧАНИЕ**
> Я использую простое соглашение об именовании для усиления связи между структурами и функциями, предназначенными для работы с этими структурами. Во-первых, я называю функции, комбинируя имя структуры, определенное через `typedef`, с именем операции (например, `Ship_active`). Во-вторых, я всегда помещаю указатель на структуру в качестве первого аргумента связанной функции, и я всегда называю этот аргумент "me" (например, `Ship_active(Ship *me, ...)`).

(15) В дополнение к функциям-обработчикам состояний, каждая стейт-машина должна объявлять **начальное псевдосостояние**, которое QEP вызывает для выполнения самого верхнего начального перехода (см. Рисунок 1.6(1)). Обработчик начального псевдосостояния имеет сигнатуру, идентичную обычной функции-обработчику состояния.

(16) В этой строке я статически выделяю хранилище для активного объекта `Ship`. Обратите внимание, что объект `l_ship` определен как `static`, поэтому он доступен только локально в пределах файла `ship.c`.

(17) В этой строке я определяю и инициализирую глобальный указатель `AO_Ship` на активный объект `Ship` (см. также Листинг 1.2(10)). Этот указатель "непрозрачен", потому что он рассматривает объект `Ship` как общую базовую структуру `QActive`, а не как специфическую структуру `Ship`. Сила "непрозрачного" указателя в том, что он позволяет мне полностью скрыть определение структуры `Ship` и сделать ее недоступной для остальной части приложения. Тем не менее, другие компоненты приложения могут получить доступ к объекту `Ship` для прямой отправки ему событий через функцию `QActive_postFIFO(QActive *me, QEvent const *e)`.

***

42
Глава 1
### 1.7.2 Шаг 2: Инициализация стейт-машины
Инициализация стейт-машины разделена на следующие два шага для повышения гибкости и лучшего контроля над временной шкалой инициализации:

1. "Конструктор" стейт-машины; и
2. Самый верхний начальный переход.

"Конструктор" стейт-машины, такой как `Ship_ctor()`, намеренно не выполняет самый верхний начальный переход, определенный в начальном псевдосостоянии, потому что в это время некоторые жизненно важные объекты могут отсутствовать, а критически важное оборудование может быть еще не правильно инициализировано.³ Вместо этого, "конструктор" стейт-машины просто переводит стейт-машину в начальное псевдосостояние. Позже пользовательский код должен явно запустить самый верхний начальный переход, что на самом деле происходит внутри функции `QActive_start()` (см. Листинг 1.1(18-20)). Листинг 1.5 показывает инстанцирование (функция-"конструктор") и инициализацию (начальное псевдосостояние) активного объекта `Ship`.

**Листинг 1.5 Инстанцирование и инициализация активного объекта Ship в ship.c**
```c
(1) void Ship_ctor(void) {          /* инстанцирование */
(2)   Ship *me = &l_ship;
(3)   QActive_ctor(&me->super, (QStateHandler)&Ship_initial);
(4)   me->x = GAME_SHIP_X;
(5)   me->y = GAME_SHIP_Y;
}
/*..........................................................................*/
(6) QState Ship_initial(Ship *me, QEvent const *e) { /* инициализация */
(7)   QActive_subscribe((QActive *)me, TIME_TICK_SIG);
(8)   QActive_subscribe((QActive *)me, PLAYER_TRIGGER_SIG);
    
(9)   return Q_TRAN(&Ship_active); /* самый верхний начальный переход */
}
```

(1) Глобальная функция `Ship_ctor()` прототипирована в `game.h` и вызывается в начале `main()`.

(2) Указатель "me" указывает на статически выделенный объект `Ship` (см. Листинг 1.4(16)).

---
³ В C++ статические конструкторы выполняются даже до `main()`.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 43
(3) Каждая производная структура отвечает за инициализацию части, унаследованной от базовой структуры. "Конструктор" `QActive_ctor()` переводит стейт-машину в начальное псевдосостояние `&Ship_initial` (см. Листинг 1.4(15)).

(4,5) Позиция `Ship` инициализируется.

(6) Функция `Ship_initial()` определяет самый верхний начальный переход в стейт-машине `Ship` (см. Рисунок 1.6(1)).

(7,8) Активный объект `Ship` подписывается на сигналы `TIME_TICK_SIG` и `PLAYER_TRIGGER_SIG`, как указано на диаграмме состояний на Рисунке 1.6(1).

(9) Начальное состояние "active" указывается путем возврата макроса QP `Q_TRAN()`.

> **ПРИМЕЧАНИЕ**
> Макрос `Q_TRAN()` всегда должен следовать за оператором `return`.

### 1.7.3 Шаг 3: Определение функций-обработчиков состояний
На последнем шаге вы фактически кодируете стейт-машину `Ship`, реализуя по одному состоянию за раз в виде функции-обработчика состояния. Чтобы определить, какие элементы принадлежат любой данной функции-обработчику состояния, вы следуете по границе состояния на диаграмме (Рисунок 1.6). Вам нужно реализовать все переходы, исходящие от границы, любые действия входа и выхода, определенные в состоянии, и все внутренние переходы, перечисленные непосредственно в состоянии. Кроме того, если внутри состояния есть встроенный начальный переход, вам нужно реализовать и его.

Возьмем, к примеру, состояние "flying", показанное на Рисунке 1.6. Это состояние имеет действие входа и два перехода, исходящих от его границы: `HIT_WALL` и `HIT_MINE(type)`, а также три внутренних перехода: `TIME_TICK`, `PLAYER_TRIGGER` и `DESTROYED_MINE(score)`. Состояние "flying" вложено в суперсостояние "active".

Листинг 1.6 показывает две функции-обработчика состояний стейт-машины `Ship` из Рисунка 1.6. Функции-обработчики состояний соответствуют состояниям "active" и "flying" соответственно. Раздел объяснений, следующий сразу за листингом, освещает важные техники реализации.

***

44
Глава 1
**Листинг 1.6 Функции-обработчики для состояний "active" и "flying" в ship.c**
```c
(1) QState Ship_active(Ship *me, QEvent const *e) {
(2)   switch (e->sig) {
(3)     case Q_INIT_SIG: {           /* вложенный начальный переход */
(4)       /* любые действия, связанные с начальным переходом */
(5)       return Q_TRAN(&Ship_parked);
        }
(6)     case PLAYER_SHIP_MOVE_SIG: {
(7)       me->x = ((ObjectPosEvt const *)e)->x;
(8)       me->y = ((ObjectPosEvt const *)e)->y;
(9)       return Q_HANDLED();
        }
    }
(10) return Q_SUPER(&QHsm_top);     /* возвращаем суперсостояние */
}
/*..........................................................................*/
QState Ship_flying(Ship *me, QEvent const *e) {
    switch (e->sig) {
(11)  case Q_ENTRY_SIG: {
(12)    ScoreEvt *sev;
        
          me->score = 0;           /* сбрасываем счет */
(13)    sev = Q_NEW(ScoreEvt, SCORE_SIG);
(14)    sev->score = me->score;
(15)    QActive_postFIFO(AO_Tunnel, (QEvent *)sev);
(16)    return Q_HANDLED();
        }
        case TIME_TICK_SIG: {
          /* сообщаем Туннелю нарисовать Корабль и проверить на попадания */
          ObjectImageEvt *oie = Q_NEW(ObjectImageEvt, SHIP_IMG_SIG);
          oie->x = me->x;
          oie->y = me->y;
          oie->bmp = SHIP_BMP;
          QActive_postFIFO(AO_Tunnel, (QEvent *)oie);

          ++me->score; /* увеличиваем счет за выживание еще один тик */
          
          if ((me->score % 10) == 0) { /* счет "круглый"? */
            ScoreEvt *sev = Q_NEW(ScoreEvt, SCORE_SIG);
            sev->score = me->score;
            QActive_postFIFO(AO_Tunnel, (QEvent *)sev);
          }
          return Q_HANDLED();
        }
        case PLAYER_TRIGGER_SIG: { /* запустить Ракету */
          ObjectPosEvt *ope = Q_NEW(ObjectPosEvt, MISSILE_FIRE_SIG);
          ope->x = me->x;
          ope->y = me->y + SHIP_HEIGHT - 1;
```

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 45
```c
          QActive_postFIFO(AO_Missile, (QEvent *)ope);
          return Q_HANDLED();
        }
        case DESTROYED_MINE_SIG: {
          me->score += ((ScoreEvt const *)e)->score;
          /* счет будет отправлен в Туннель при следующем TIME_TICK */
          return Q_HANDLED();
        }
(17)  case HIT_WALL_SIG:
(18)  case HIT_MINE_SIG: {
(19)    /* любые действия, связанные с переходом */
(20)    return Q_TRAN(&Ship_exploding);
        }
    }
(21) return Q_SUPER(&Ship_active); /* возвращаем суперсостояние */
}
```

(1) Каждый обработчик состояния должен иметь одинаковую сигнатуру, то есть он должен принимать два параметра: указатель на стейт-машину "me" и указатель на QEvent. Ключевое слово `const` перед `*` в объявлении указателя на событие означает, что событие, на которое указывает этот указатель, не может быть изменено внутри функции-обработчика состояния (т.е. событие доступно только для чтения). Функция-обработчик состояния должна возвращать `QState`, который передает статус обработки события обработчику событий QEP.

(2) Обычно каждый обработчик состояния структурирован как оператор `switch`, который различает события на основе сигнала `e->sig`.

(3) Эта строка кода относится к вложенному начальному переходу на Рисунке 1.6(2). QEP предоставляет зарезервированный сигнал `Q_INIT_SIG`, который фреймворк передает функции-обработчику состояния, когда он хочет выполнить начальный переход.

(4) Вы можете перечислить любые действия, связанные с этим начальным переходом (в данном конкретном случае их нет).

(5) Вы указываете целевое подсостояние с помощью макроса `Q_TRAN()`. Этот макрос всегда должен следовать за оператором `return`, через который функция-обработчик состояния информирует обработчик событий QEP о том, что переход был выполнен.

***

46
Глава 1
> **ПРИМЕЧАНИЕ**
> Начальный переход должен обязательно указывать на прямое или транзитивное подсостояние данного состояния. Начальный переход не может указывать на соседнее состояние или подниматься по иерархии состояний на более высокие уровни, что в UML представляло бы собой "некорректную" стейт-машину.

(6) Эта строка кода относится к внутреннему переходу `PLAYER_SHIP_MOVE_SIG(x, y)` на Рисунке 1.6(3).

(7,8) Вы получаете доступ к членам данных стейт-машины `Ship` через аргумент "me" функции-обработчика состояния. Вы получаете доступ к параметрам события через аргумент "e". Вам нужно привести указатель на событие из базового класса `QEvent` к конкретной структуре события, ожидаемой для `PLAYER_SHIP_MOVE_SIG`, которая в данном случае является `ObjectPosEvt`.

> **ПРИМЕЧАНИЕ**
> Связь между сигналом события и структурой события (параметрами события) устанавливается в момент генерации события. Все получатели этого события должны знать об этой связи, чтобы выполнить приведение к правильной структуре события.

(9) Вы завершаете оператор `case` с "return QHandled()", что информирует процессор QEP о том, что событие было обработано, но переход не был совершен.

(10) Финальный `return` из функции-обработчика состояния обозначает **суперсостояние** этого состояния с помощью макроса QEP `Q_SUPER()`. Финальный оператор `return` из функции-обработчика состояния представляет собой единственную точку обслуживания для изменения уровня вложенности данного состояния. Состояние "active" на Рисунке 1.6 не имеет явного суперсостояния, что означает, что оно неявно вложено в "верхнее" состояние. "Верхнее" состояние — это концепция UML, которая обозначает конечный корень иерархии состояний в иерархической стейт-машине. QEP предоставляет "верхнее" состояние в виде функции-обработчика `QHsm_top()`, и поэтому обработчик состояния `Ship_active()` использует указатель `&QHsm_top` в качестве аргумента макроса `Q_SUPER()`.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 47
> **ПРИМЕЧАНИЕ**
> В C и C++ указатель на функцию `QHsm_top()` можно записать как `QHsm_top` или `&QHsm_top`. Несмотря на то, что нотация `QHsm_top` более краткая, я предпочитаю добавлять амперсанд явно, чтобы не оставлять абсолютно никаких сомнений в том, что я имею в виду указатель на функцию `&QHsm_top`.

(11) Эта строка кода относится к **действию входа** в состояние "flying" (Рисунок 1.6(5)). QEP предоставляет зарезервированный сигнал `Q_ENTRY_SIG`, который фреймворк передает функции-обработчику состояния, когда он хочет выполнить действия входа.

(12) Действие входа в "flying" отправляет событие `SCORE` активному объекту `Tunnel` (Рисунок 1.6(5)). Эта строка определяет временный указатель на структуру события `ScoreEvt`.

(13) Макрос QF `Q_NEW(ScoreEvt, SCORE_SIG)` динамически выделяет экземпляр `ScoreEvt` из пула событий, управляемого QF. Макрос также выполняет связывание сигнала `SCORE_SIG` с выделенным событием. Макрос `Q_NEW()` возвращает указатель на выделенное событие.

(14) Параметр `score` `ScoreEvt` устанавливается из члена стейт-машины `me->score`.

(15) Событие `sev` отправляется напрямую активному объекту `Tunnel` с помощью функции QP `QActive_postFIFO()`. Аргументами этой функции являются принимающий активный объект (`AO_Tunnel` в данном случае) и указатель на событие (временный указатель `sev` в данном случае).

(16) Вы завершаете оператор `case` с `return Q_Handled()`, что информирует QEP о том, что действия входа были обработаны.

(17,18) Эти две строки кода относятся к **переходам состояний** из "flying" в "exploding" (Рисунок 1.6(9, 10)).

(19) Вы можете перечислить любые действия, связанные с переходом (в данном конкретном случае их нет).

(20) Вы указываете цель перехода с помощью макроса `Q_TRAN()`.

***

48
Глава 1
(21) Финальный `return` из функции-обработчика состояния обозначает *суперсостояние* этого состояния. Состояние "flying" на Рисунке 1.6 вложено в состояние "active", поэтому обработчик состояния `Ship_flying()` возвращает указатель `&Ship_active`.

При реализации функций-обработчиков состояний нужно помнить, что здесь управляет обработчик событий QEP, а не ваш код. QEP будет вызывать функцию-обработчик состояния по разным причинам: для иерархической обработки событий, для выполнения действий входа и выхода, для запуска начальных переходов или даже просто для получения суперсостояния данного обработчика состояния. Поэтому не следует предполагать, что обработчик состояния будет вызываться только для обработки сигналов, перечисленных в операторах `case`. Следует избегать любого кода вне оператора `switch`, особенно кода, который может иметь побочные эффекты.

## 1.8 Модель выполнения
Как вы видели в Листинге 1.1(21), функция `main()` в конечном итоге передает управление событийно-управляемому фреймворку, вызывая `QF_run()` для выполнения приложения. В этом разделе я кратко объясню, как QF распределяет циклы ЦП между различными задачами в системе и какие у вас есть варианты выбора модели выполнения.

### 1.8.1 Простой невытесняющий планировщик "Vanilla"
Пример "Fly 'n' Shoot" использует простейшую конфигурацию QF, в которой QF работает на "голом железе" целевого процессора без какой-либо базовой операционной системы или ядра.⁴ Я называю такую конфигурацию QF "простой ванилью" или просто "ванилью".

QF включает простое невытесняющее ядро "vanilla", которое выполняет по одному активному объекту за раз в бесконечном цикле (подобно "суперциклу"). Ядро "vanilla" задействуется после обработки каждого события в режиме "выполнение до завершения" (RTC), чтобы выбрать следующий готовый к обработке события активный объект с наивысшим приоритетом. Планировщик "vanilla" является кооперативным, что означает, что все активные объекты сотрудничают, разделяя один ЦП, и неявно уступают друг другу после каждого шага RTC. Ядро является невытесняющим, что означает, что каждый активный объект должен полностью обработать событие, прежде чем любой другой активный объект сможет начать обработку другого события.

---
⁴ Версия 80×86 игры "Fly 'n' Shoot" работает поверх DOS, но DOS не предоставляет поддержки многозадачности.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 49
ISR могут вытеснять выполнение активных объектов в любое время, но из-за упрощенной природы ядра "vanilla", каждый ISR возвращается точно в точку вытеснения. Если ISR отправляет или публикует событие какому-либо активному объекту, обработка этого события не начнется до завершения текущего шага RTC. Максимальное время, на которое может быть отложено событие для активного объекта с наивысшим приоритетом, называется **откликом на уровне задачи**. С невытесняющим ядром "vanilla" отклик на уровне задачи равен самому длинному шагу RTC из всех активных объектов в системе. Обратите внимание, что отклик на уровне задачи ядра "vanilla" все еще намного лучше, чем у традиционной архитектуры "суперцикла" (также известной как main+ISRs). Я расскажу об этом подробнее в предстоящем Разделе 1.9, где я сравниваю событийно-управляемый пример "Fly 'n' Shoot" с традиционно структурированным приложением Quickstart.

Отклик на уровне задачи простого ядра "vanilla" оказывается достаточным для удивительно многих приложений, потому что стейт-машины по своей природе обрабатывают события быстро, без необходимости ожидания событий в цикле. (Стейт-машина просто выполняется до завершения и становится неактивной до прибытия другого события.) Также обратите внимание, что часто вы можете сделать отклик на уровне задачи таким быстрым, как вам нужно, разбивая более длинные шаги RTC на более короткие (например, используя паттерн состояния "Напоминание", описанный в Главе 5).

### 1.8.2 Вытесняющее ядро QK
В некоторых случаях разбиение длинных шагов RTC на достаточно короткие части может быть очень сложным, и, следовательно, отклик на уровне задачи невытесняющего ядра "vanilla" может быть слишком долгим. Примером такой системы может быть GPS-приемник. Такой приемник выполняет много вычислений с плавающей точкой на ЦП с фиксированной точкой для расчета местоположения по GPS. В то же время GPS-приемник должен отслеживать сигналы спутников GPS, что включает в себя замыкание контуров управления с интервалами в субмиллисекунды. Оказывается, нелегко разбить вычисление местоположения на достаточно короткие шаги RTC, чтобы обеспечить надежное отслеживание сигнала.

Но семантика выполнения стейт-машины RTC не означает, что стейт-машина должна монополизировать ЦП на время шага RTC. Вытесняющее ядро может выполнить переключение контекста в середине длинного шага RTC, чтобы позволить работать активному объекту с более высоким приоритетом. Пока активные объекты не разделяют ресурсы, они могут работать параллельно и завершать свои шаги RTC независимо (см. также Раздел 6.3.3 в Главе 6).

Событийно-управляемая платформа QP включает крошечный, полностью **вытесняющий**, основанный на приоритетах компонент ядра реального времени под названием **QK**, который специально разработан для обработки

***

50
Глава 1
событий в режиме RTC. Настройка QP для использования вытесняющего ядра QK очень проста, но, как и с любым полностью вытесняющим ядром, вы должны быть очень осторожны с любыми ресурсами, разделяемыми между активными объектами.⁵ Пример "Fly 'n' Shoot" был специально разработан так, чтобы избежать любого разделения ресурсов между активными объектами, поэтому код приложения не требует никаких изменений для работы поверх вытесняющего ядра QK или любого другого вытесняющего ядра или ОСРВ. Сопутствующий код содержит пример "Fly 'n' Shoot" с QK в следующем каталоге: `<qp>\qpc\examples\80x86\qk\tcpp101\1\game\`. Вы можете запустить этот пример в DOS-консоли на любом стандартном ПК с Windows.

### 1.8.3 Традиционная ОС/ОСРВ
QP также может работать с традиционной операционной системой (ОС), такой как Windows или Linux, или практически с любой операционной системой реального времени (ОСРВ), чтобы использовать существующие драйверы устройств, стеки протоколов и другое промежуточное ПО.

QP содержит уровень абстракции платформы (PAL), который упрощает адаптацию QP практически к любой операционной системе. Тщательно разработанный PAL позволяет тесно интегрироваться с базовой ОС/ОСРВ, повторно используя любые предоставленные средства для управления прерываниями, очередями сообщений и разделами памяти. Я рассматриваю портирование QP в Главе 8.

## 1.9 Сравнение с традиционным подходом
Игра "Fly 'n' Shoot" намеренно ведет себя почти идентично приложению Quickstart, предоставленному в исходном коде с оценочным комплектом Luminary Micro Stellaris EV-LM3S811 [Luminary 06]. В этом разделе я хотел бы сравнить традиционный подход, представленный приложением Quickstart, с решением на основе стейт-машин, примером которого является игра "Fly 'n' Shoot".

Рисунок 1.11(A) схематически показывает блок-схему приложения Quickstart; Рисунок 1.11(B) показывает блок-схему игры "Fly 'n' Shoot", работающей поверх кооперативного ядра "vanilla". На самом высоком уровне блок-схемы похожи тем, что обе состоят из бесконечного цикла, окружающего всю обработку. Но внутренняя структура основного цикла в этих двух случаях очень разная. Как показывают жирные

---
⁵ QK предоставляет мьютекс для обеспечения взаимоисключающего доступа к общим ресурсам. Мьютекс QK использует протокол потолка приоритетов для избежания инверсии приоритетов. Обратитесь к Главе 10 для получения дополнительной информации.

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 51
линии на блок-схемах, приложение Quickstart проводит большую часть своего времени в тесных "циклах событий", предназначенных для активного ожидания определенных событий, таких как событие обновления экрана. В отличие от этого, приложение "Fly 'n' Shoot" проводит большую часть своего времени прямо в основном цикле. Фреймворк QP отправляет любое доступное событие соответствующей стейт-машине, которая обрабатывает событие, и быстро возвращается в основной цикл, никогда не ожидая событий внутри.

**(Изображение: Две блок-схемы, сравнивающие поток управления)**

**Рисунок 1.11:** Поток управления в приложении Quickstart (A) и в примере "Fly 'n' Shoot" (B). Жирные линии представляют наиболее часто выполняемые пути в коде.

**A (Quickstart):**
- ScreenSaver()
- MainScreen()
  - Активное ожидание события обновления экрана
- PlayGame()
  - Активное ожидание события обновления экрана

**B ("Fly 'n' Shoot"):**
- QF_run()
  - QF_start()
  - Цикл:
    - событие доступно?
      - Да: QHsm_dispatch()
      - Нет: QF_onIdle()

Приложение Quickstart имеет гораздо более запутанный поток управления, чем пример "Fly 'n' Shoot", потому что традиционное решение очень специфично для решаемой задачи, тогда как подход со стейт-машинами является общим. Приложение Quickstart структурировано очень похоже на традиционную последовательную программу, которая пытается контролировать все

***

52
Глава 1
от начала до конца. Время от времени приложение приостанавливается для активного ожидания определенного события, в то время как код в целом не готов обрабатывать какие-либо другие события, кроме того, которое он решил ожидать. Все это способствует негибкости дизайна. Добавление новых событий затруднено, потому что вся структура промежуточного кода разработана для приема только очень специфических событий и потребует кардинальных изменений для accommodating новых событий. Кроме того, во время активного ожидания события обновления экрана (эквивалентного событию `TIME_TICK` в примере "Fly 'n' Shoot"), приложение на самом деле не реагирует ни на какие другие события. Отклик на уровне задачи трудно охарактеризовать, и он в целом зависит от типа события. Временные рамки, установленные жестко закодированным ожиданием существующих событий, могут плохо работать для новых событий.

В отличие от этого, приложение "Fly 'n' Shoot" имеет гораздо более простой поток управления, который является чисто событийно-управляемым и полностью общим (см. Рисунок 1.11(B)). Контекст каждого компонента активного объекта представлен как текущее состояние стейт-машины, а не как определенное место в коде. Таким образом, зависание в тесных "циклах событий" вокруг определенных мест в коде, соответствующих текущему контексту, не требуется. Вместо этого стейт-машина очень эффективно запоминает контекст в виде небольшого элемента данных (переменной состояния; см. Главу 3). После обработки каждого события стейт-машина может вернуться в общий цикл обработки событий, который разработан для обработки всех видов событий. Для каждого события стейт-машина естественным образом продолжает работу с того места, где она остановилась, и переходит в следующее состояние, если это необходимо. Добавление новых событий в этом дизайне легко, потому что стейт-машина реагирует на любое событие в любое время. Событийно-управляемое, основанное на стейт-машинах приложение несравнимо более гибкое и устойчивое к изменениям, чем традиционное.

> **ПРИМЕЧАНИЕ**
> Общий цикл обработки событий также может очень легко обнаружить ситуацию, когда нет доступных событий, в этом случае фреймворк QP вызывает функцию `QF_onIdle()` (см. Рисунок 1.11(B)). Эта функция обратного вызова предназначена для настройки приложением и является идеальным местом для перевода ЦП в режим сна с низким энергопотреблением для экономии энергии. В отличие от этого, традиционный подход не предлагает единого места для перехода в режим сна с низким энергопотреблением и, следовательно, гораздо менее удобен для реализации действительно энергоэффективных дизайнов.

## 1.10 Заключение
Если вы никогда раньше не занимались событийно-управляемым программированием, внутренняя структура игры "Fly 'n' Shoot", безусловно, должна представлять для вас большой сдвиг парадигмы. На самом деле,

***

Начало работы с UML стейт-машинами и событийно-управляемым программированием 53
я надеюсь, что это действительно взрывает ваш мозг, потому что в противном случае я не уверен, что вы действительно оцените полный переворот управления в событийно-управляемой программе по сравнению с традиционным последовательным кодом. Этот переворот управления, известный как **Принцип Голливуда** (не звоните нам, мы сами вам позвоним), сбивает с толку многих новичков, которые часто находят его "умопомрачительным", "обратным" или "странным".

Игра "Fly 'n' Shoot" ни в коем случае не является большим приложением, но в то же время она определенно не тривиальна. Не стоит беспокоиться, если вы не полностью поняли ее с первого прочтения. В следующих главах я представлю более подробный взгляд на техники проектирования и кодирования стейт-машин. В Части II я обсуждаю особенности, реализацию и портирование фреймворка реального времени QF.

Моя главная цель в этой главе заключалась в том, чтобы просто познакомить вас с событийно-управляемой парадигмой и современными стейт-машинами, чтобы убедить вас, что эти мощные концепции не особенно сложны для реализации непосредственно на C или C++. Действительно, я надеюсь, вы заметили, что фактическое кодирование нетривиальной игры "Fly 'n' Shoot" вовсе не было сложным делом. Все, что вам нужно было знать, — это всего лишь несколько шаблонных правил для кодирования стейт-машин и знакомство с несколькими сервисами фреймворка для реализации действий.

Хотя кодирование оказалось, по сути, несложной задачей, основная часть усилий по программированию была потрачена на *проектирование* приложения. На данном этапе я надеюсь, что пример "Fly 'n' Shoot" поможет вам получить общее представление о том, как работает метод. В событийно-управляемой модели структура программы делится на две грубые группы: события и компоненты стейт-машин (активные объекты). Событие представляет собой возникновение чего-то интересного. Стейт-машина кодифицирует реакции на события, которые обычно зависят как от природы события, так и от состояния компонента. Хотя события часто возникают извне вашей программы, например, тики времени или нажатия кнопок в игре "Fly 'n' Shoot", события также могут генерироваться внутри самой программой. Например, компоненты `Mine` генерируют уведомляющие события, когда они обнаруживают столкновение с `Missile` или `Ship`.

Событийно-управляемая программа выполняется, постоянно проверяя возможные события и, когда событие обнаружено, отправляя его соответствующему компоненту стейт-машины (см. Рисунок 1.11(B)). Чтобы этот подход работал, события должны проверяться непрерывно и часто. Это подразумевает, что стейт-машины должны выполняться быстро, чтобы программа могла вернуться к проверке событий. Чтобы удовлетворить этому требованию, стейт-машина не может входить в состояние, в котором она активно ожидает в течение длительного или неопределенного времени. Самым распространенным примером этого был бы цикл `while` внутри функции-обработчика состояния, где условие завершения не находилось под контролем программы.

***

54
Глава 1
контроля — например, нажатие кнопки. Этот вид структуры программы, бесконечный цикл, называется "блокирующим" кодом,⁶ и вы видели его примеры в приложении Quickstart (см. Рисунок 1.11(A)). Чтобы модель событийно-управляемого программирования работала, вы должны писать только "неблокирующий" код [Carryer 05].

Наконец, пример "Fly 'n' Shoot" демонстрирует использование событийно-управляемой платформы под названием QP, которая представляет собой набор компонентов для создания событийно-управляемых приложений. Компонент фреймворка реального времени QF воплощает Принцип Голливуда, вызывая код приложения, а не наоборот. Такое устройство очень типично для событийно-управляемых систем, и фреймворки приложений, подобные QF, лежат в основе практически каждого инструмента автоматизации проектирования на рынке сегодня.

Фреймворк QF работает в игре "Fly 'n' Shoot" в своей простейшей конфигурации, в которой QF работает на "голом железе" целевого процессора без какой-либо операционной системы. QF также может быть сконфигурирован для работы со встроенным вытесняющим ядром реального времени под названием QK (см. Главу 10) или может быть легко портирован практически на любую традиционную ОС или ОСРВ (см. Главу 8). Фактически, вы можете рассматривать сам фреймворк QF как высокоуровневую, событийно-управляемую операционную систему реального времени.

---
⁶ В контексте многозадачной операционной системы "блокирующий" код соответствует ожиданию на семафоре, флаге события, почтовом ящике сообщений или другом подобном примитиве операционной системы.
Use Arrow Up and Arrow Down to select a turn, Enter to jump to it, and Escape to return to the chat.
